<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FNAF Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    @font-face {
      font-family: 'FNAF';
      src: url('../Assets/Fonts/five-nights-at-freddys.otf') format('opentype');
    }

    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      cursor: grab;
      user-select: none;
    }
    body.dragging { cursor: grabbing; }
    canvas { display: block; position: absolute; top: 0; left: 0; }

    /* ── HUD ──────────────────────────────────────────────────── */
    #hud-top-right {
      position: fixed;
      top: var(--hud-tr-top, 37px);
      right: var(--hud-tr-right, 50px);
      z-index: 500;
      pointer-events: none;
      user-select: none;
      font-family: 'FNAF', 'Courier New', monospace;
      color: #fff;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      text-align: right;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    #hud-time {
      font-size: calc(clamp(24px, 3.6vw, 56px) * var(--hud-tr-scale, 1.6));
      letter-spacing: 0.06em;
      line-height: 1;
    }
    #hud-night {
      font-size: calc(clamp(13px, 1.6vw, 26px) * var(--hud-tr-scale, 1.6));
      letter-spacing: 0.08em;
      opacity: 0.9;
    }

    #hud-power {
      position: fixed;
      bottom: var(--hud-pw-bottom, 123px);
      left: var(--hud-pw-left, 70px);
      z-index: 500;
      pointer-events: none;
      user-select: none;
      font-family: 'FNAF', 'Courier New', monospace;
      color: #fff;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      font-size: calc(clamp(13px, 1.6vw, 26px) * var(--hud-bl-scale, 2.25));
      letter-spacing: 0.08em;
    }

    #hud-usage {
      position: fixed;
      bottom: var(--hud-us-bottom, 61px);
      left: var(--hud-us-left, 70px);
      z-index: 500;
      pointer-events: none;
      user-select: none;
      font-family: 'FNAF', 'Courier New', monospace;
      color: #fff;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      font-size: calc(clamp(13px, 1.6vw, 26px) * var(--hud-bl-scale, 2.25));
      letter-spacing: 0.08em;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #hud-battery-img {
      height: clamp(28px, 4vw, 52px);
      width: auto;
      image-rendering: pixelated;
    }

    /* Page fade-in on load */
    #page-fade {
      position: fixed;
      inset: 0;
      z-index: 998;
      background: #000;
      opacity: 1;
      pointer-events: none;
      transition: opacity 0.9s ease;
    }

    /* Invisible click zones for buttons */
    .btn-zone {
      position: absolute;
      cursor: pointer;
      z-index: 10;
    }

    #debug {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.88);
      color: #0f0;
      font: 11px monospace;
      padding: 12px;
      border: 1px solid #0f0;
      z-index: 600;
      width: 240px;
      max-height: 90vh;
      overflow-y: auto;
    }
    #debug label { display: block; margin-top: 6px; }
    #debug input[type=range] { width: 100%; }
    #debug .val { color: #ff0; float: right; }
    #debug h3 { color: #0f0; margin-bottom: 2px; }
    #debug h4 { color: #aaffaa; margin-top: 8px; margin-bottom: 2px; }
    #debug .hint { color: #888; font-size: 10px; margin-top: 6px; }
    #copy-btn { margin-top: 8px; width: 100%; background: #0a0; color: #fff; border: none; padding: 4px; cursor: pointer; font: 11px monospace; }

    /* Tablet bar */
    #tablet-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40px;
      background: #1a1a1a;
      border-top: 2px solid #333;
      z-index: 550;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #tablet-bar img { height: 30px; opacity: 0.7; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="page-fade"></div>

<!-- HUD top-right: time + night -->
<div id="hud-top-right">
  <div id="hud-time">12 AM</div>
  <div id="hud-night">Night 1</div>
</div>

<!-- HUD bottom-left: power % -->
<div id="hud-power">Power Left: <span id="hud-power-val">99%</span></div>

<!-- HUD usage: label + battery image -->
<div id="hud-usage">
  <span>Usage :</span>
  <img id="hud-battery-img" src="../Assets/Battery/212.png" alt="battery">
</div>

<div id="debug">
  <h3>Debug [D to hide]</h3>
  <h4>Left Button</h4>
  <label>X: <span class="val" id="vlx">0</span>
    <input type="range" id="slx" min="0" max="3000" value="0">
  </label>
  <label>Y: <span class="val" id="vly">261</span>
    <input type="range" id="sly" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vlsc">1.00</span>
    <input type="range" id="slsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Button</h4>
  <label>X: <span class="val" id="vrx">1478</span>
    <input type="range" id="srx" min="0" max="3000" value="1478">
  </label>
  <label>Y: <span class="val" id="vry">261</span>
    <input type="range" id="sry" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vrsc">1.00</span>
    <input type="range" id="srsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Left Door</h4>
  <label>X: <span class="val" id="vldx">73</span>
    <input type="range" id="sldx" min="-500" max="3000" value="73">
  </label>
  <label>Y: <span class="val" id="vldy">41</span>
    <input type="range" id="sldy" min="-500" max="1500" value="41">
  </label>
  <label>Scale: <span class="val" id="vldsc">1.00</span>
    <input type="range" id="sldsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Door</h4>
  <label>X: <span class="val" id="vrdx">1263</span>
    <input type="range" id="srdx" min="-500" max="3000" value="1263">
  </label>
  <label>Y: <span class="val" id="vrdy">31</span>
    <input type="range" id="srdy" min="-500" max="1500" value="31">
  </label>
  <label>Scale: <span class="val" id="vrdsc">1.00</span>
    <input type="range" id="srdsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <div class="hint">Coords in source image pixels.</div>
  <button id="copy-btn">Copy values</button>
  <h4>HUD Top-Right</h4>
  <label>Top: <span class="val" id="vhtr-t">37</span>px
    <input type="range" id="shtr-t" min="0" max="200" value="37">
  </label>
  <label>Right: <span class="val" id="vhtr-r">50</span>px
    <input type="range" id="shtr-r" min="0" max="200" value="50">
  </label>
  <label>Size: <span class="val" id="vhtr-s">1.60</span>x
    <input type="range" id="shtr-s" min="0.5" max="3" step="0.05" value="1.6">
  </label>
  <h4>HUD Power Left</h4>
  <label>Bottom: <span class="val" id="vhpw-b">123</span>px
    <input type="range" id="shpw-b" min="0" max="400" value="123">
  </label>
  <label>Left: <span class="val" id="vhpw-l">70</span>px
    <input type="range" id="shpw-l" min="0" max="400" value="70">
  </label>
  <h4>HUD Usage / Battery</h4>
  <label>Bottom: <span class="val" id="vhus-b">61</span>px
    <input type="range" id="shus-b" min="0" max="400" value="61">
  </label>
  <label>Left: <span class="val" id="vhus-l">70</span>px
    <input type="range" id="shus-l" min="0" max="400" value="70">
  </label>
  <label>Text Size: <span class="val" id="vhbl-s">2.25</span>x
    <input type="range" id="shbl-s" min="0.5" max="3" step="0.05" value="2.25">
  </label>
  <button id="copy-hud-btn" style="margin-top:6px;width:100%;background:#00a;color:#fff;border:none;padding:4px;cursor:pointer;font:11px monospace;">Copy HUD values</button>
</div>

<div id="tablet-bar">
  <img src="../Assets/Tablette/open_tablette_icon.png" alt="tablet">
</div>
<canvas id="tablet-anim-canvas" style="display:none;position:fixed;inset:0;width:100%;height:100%;z-index:45;"></canvas>
<canvas id="tablet-cam" style="display:none;position:fixed;inset:0;z-index:44;background:#000;width:100%;height:100%;"></canvas>

<script src="animations.js"></script>
<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H;
  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // --- Audio ---
  const audioBase = '../Assets/FNaF 1 Audio/';
  const sfxFan   = new Audio(audioBase + 'Buzz_Fan_Florescent2.wav');
  sfxFan.loop = true; sfxFan.volume = 0.5;
  const sfxPhone = new Audio(audioBase + 'voiceover1c.wav');
  sfxPhone.volume = 0.5;
  const ambienceSrcs = [audioBase + 'ambience2.wav', audioBase + 'EerieAmbienceLargeSca_MV005.wav'];
  const sfxScream  = new Audio('../Assets/FNaF 1 Audio/XSCREAM.wav');
  const sfxScream2 = new Audio('../Assets/FNaF 1 Audio/XSCREAM2.wav');
  const sfxNoise   = new Audio('../Assets/FNaF 1 Audio/COMPUTER_DIGITAL_L2076505.wav');
  let audioStarted = false;

  let currentAmbience = null;
  function startAudio() {
    if (audioStarted) return;
    audioStarted = true;
    sfxFan.play().catch(() => {});
    sfxPhone.play().catch(() => {});
    function nextAmbience() {
      currentAmbience = new Audio(ambienceSrcs[Math.floor(Math.random() * ambienceSrcs.length)]);
      currentAmbience.volume = 0.4;
      currentAmbience.play().catch(() => {});
      currentAmbience.addEventListener('ended', nextAmbience);
    }
    nextAmbience();
  }
  window.onload = () => { startAudio(); };

  // --- Background images ---
  const bg = new Image();
  bg.src = '../assets/Main Room/39.png';

  const bgLit = { left: new Image(), right: new Image() };
  bgLit.left.src  = '../Assets/Main Room/main_room_left_open_lit.png';
  bgLit.right.src = '../Assets/Main Room/main_room_right_open_lit.png';

  const bgPoweredDown = new Image();
  bgPoweredDown.src = '../Assets/Main Room/304.png';
  const bgFreddyEyesImg = new Image();
  bgFreddyEyesImg.src = '../Assets/Main Room/305.png';

  // ── Light flicker ─────────────────────────────────────────────
  const FLICKER_SEQUENCE = [
    { lit: true,  delay: 40  },
    { lit: false, delay: 60  },
    { lit: true,  delay: 30  },
    { lit: false, delay: 80  },
    { lit: true,  delay: 50  },
    { lit: false, delay: 45  },
    { lit: true,  delay: 120 },
    { lit: false, delay: 35  },
    { lit: true,  delay: 0   },
  ];
  const flickerOverride = { left: null, right: null };
  let flickerTimers = { left: [], right: [] };

  function triggerFlicker(side) {
    flickerTimers[side].forEach(t => clearTimeout(t));
    flickerTimers[side] = [];
    flickerOverride[side] = null;
    let cumulative = 0;
    FLICKER_SEQUENCE.forEach(({ lit, delay }, i) => {
      const t = setTimeout(() => {
        const isLast = (i === FLICKER_SEQUENCE.length - 1);
        if (state[side].light === 'on') {
          flickerOverride[side] = isLast ? null : (lit ? 'on' : 'off');
        } else {
          flickerOverride[side] = null;
        }
        updateLightAudio();
      }, cumulative);
      flickerTimers[side].push(t);
      cumulative += delay;
    });
  }

  function getActiveBg() {
    if (window._powerOutEyeFrame === '305') {
      return bgFreddyEyesImg.complete && bgFreddyEyesImg.naturalWidth ? bgFreddyEyesImg : bgPoweredDown;
    }
    if (powerOut) {
      return bgPoweredDown.complete && bgPoweredDown.naturalWidth ? bgPoweredDown : bg;
    }
    const leftLit  = state.left.light  === 'on';
    const rightLit = state.right.light === 'on';
    const leftEffective  = leftLit  && flickerOverride.left  !== 'off';
    const rightEffective = rightLit && flickerOverride.right !== 'off';
    if (leftEffective  && !rightEffective) return bgLit.left.complete  && bgLit.left.naturalWidth  ? bgLit.left  : bg;
    if (rightEffective && !leftEffective)  return bgLit.right.complete && bgLit.right.naturalWidth ? bgLit.right : bg;
    return bg;
  }

  // --- Fan ---
  const fanFrames = fanAnimation.frames.map(src => {
    const img = new Image(); img.src = src; return img;
  });
  let fanIndex = 0, fanLoaded = 0;
  fanFrames.forEach(f => {
    f.onload  = () => { fanLoaded++; if (fanLoaded === fanFrames.length) setInterval(() => { fanIndex = (fanIndex + 1) % fanFrames.length; }, 1000 / fanAnimation.fps); };
    f.onerror = () => { fanLoaded++; };
  });

  // --- Doors ---
  const sfxDoor  = new Audio('../Assets/FNaF 1 Audio/SFXBible_12478.wav');
  sfxDoor.volume = 0.8;
  const sfxLight = new Audio('../Assets/FNaF 1 Audio/BallastHumMedium2.wav');
  sfxLight.loop = true; sfxLight.volume = 0.6;

  function updateLightAudio() {
    const leftOn  = state.left.light  === 'on' && flickerOverride.left  !== 'off';
    const rightOn = state.right.light === 'on' && flickerOverride.right !== 'off';
    if (leftOn || rightOn) {
      if (sfxLight.paused) sfxLight.play().catch(() => {});
    } else {
      sfxLight.pause(); sfxLight.currentTime = 0;
    }
  }

  function loadDoorFrames(animDef) {
    return animDef.frames.map(src => {
      const img = new Image(); img.src = src;
      img.onerror = () => console.warn('Missing door frame:', src);
      return img;
    });
  }
  const doorFrames = { left: loadDoorFrames(mainRoomDoorLeft), right: loadDoorFrames(mainRoomDoorRight) };
  const doorAnim   = { left: { frameIndex: 0, direction: 0, timer: null }, right: { frameIndex: 0, direction: 0, timer: null } };

  function stepDoor(side) {
    const anim = doorAnim[side], frames = doorFrames[side];
    anim.frameIndex += anim.direction;
    if (anim.frameIndex >= frames.length) {
      anim.frameIndex = frames.length - 1; anim.direction = 0;
      clearInterval(anim.timer); anim.timer = null; state[side].door = 'closed';
    } else if (anim.frameIndex <= 0) {
      anim.frameIndex = 0; anim.direction = 0;
      clearInterval(anim.timer); anim.timer = null; state[side].door = 'open';
    }
  }
  function startDoorAnim(side, direction) {
    const anim = doorAnim[side], def = side === 'left' ? mainRoomDoorLeft : mainRoomDoorRight;
    if (anim.direction === direction) return;
    anim.direction = direction;
    if (anim.timer) { clearInterval(anim.timer); anim.timer = null; }
    anim.timer = setInterval(() => stepDoor(side), 1000 / def.fps);
  }
  function toggleDoor(side) {
    const anim = doorAnim[side];
    sfxDoor.currentTime = 0; sfxDoor.play().catch(() => {});
    if (anim.direction === 1 || (anim.direction === 0 && anim.frameIndex === doorFrames[side].length - 1)) {
      startDoorAnim(side, -1);
    } else {
      startDoorAnim(side, 1);
    }
  }

  // --- Buttons ---
  const btnBase = '../Assets/Door_Buttons/';
  function loadBtn(side, light, door) {
    const img = new Image(); img.src = `${btnBase}Button_${side}_light_${light}_${door}.png`; return img;
  }
  const btnImgs = {
    left:  { off_closed: loadBtn('left','off','closed'), off_open: loadBtn('left','off','open'), on_closed: loadBtn('left','on','closed'), on_open: loadBtn('left','on','open') },
    right: { off_closed: loadBtn('right','off','closed'), off_open: loadBtn('right','off','open'), on_closed: loadBtn('right','on','closed'), on_open: loadBtn('right','on','open') },
  };
  const state = { left: { door: 'closed', light: 'off' }, right: { door: 'closed', light: 'off' } };
  function getBtnImg(side) { const s = state[side]; return btnImgs[side][`${s.light}_${s.door}`]; }
  [...Object.values(btnImgs.left), ...Object.values(btnImgs.right)].forEach(img => { img.onerror = () => console.warn('Missing:', img.src); });

  bg.onload = () => requestAnimationFrame(animate);

  // --- Pan ---
  let scroll = 0.5, targetScroll = 0.5, isDragging = false, lastX = 0, velocity = 0;
  let btnPos  = { left: { x: 0, y: 261, scale: 1.0 }, right: { x: 1478, y: 261, scale: 1.0 } };
  let doorPos = { left: { x: mainRoomDoorLeft.imgX, y: mainRoomDoorLeft.imgY, scale: mainRoomDoorLeft.scale }, right: { x: mainRoomDoorRight.imgX, y: mainRoomDoorRight.imgY, scale: mainRoomDoorRight.scale } };

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  const FOV_FACTOR = 0.35;

  function drawStripLayer(img, imgW, imgH, scale, offsetX) {
    for (let sx = 0; sx < W; sx++) {
      const imgX = (offsetX + sx) / scale;
      if (imgX < 0 || imgX >= imgW) continue;
      const screenNorm = (sx / W - 0.5) * 2;
      const dist = Math.sqrt(1 + (screenNorm * FOV_FACTOR) ** 2);
      const stripH = H / dist;
      ctx.drawImage(img, imgX, 0, 1, imgH, sx, (H - stripH) / 2, 1, stripH);
    }
  }
  function drawSprite(img, imgSpace, scale, offsetX) {
    if (!img.complete || !img.naturalWidth) return;
    ctx.drawImage(img, imgSpace.x * scale - offsetX, imgSpace.y * scale, img.naturalWidth * scale * imgSpace.scale, img.naturalHeight * scale * imgSpace.scale);
  }
  function getBtnScreenRect(side) {
    if (!bg || !bg.complete || !bg.naturalWidth) return null;
    const scale = H / bg.naturalHeight, maxOffset = (bg.naturalWidth * scale) - W, offsetX = scroll * maxOffset;
    const pos = btnPos[side], img = getBtnImg(side);
    if (!img.complete || !img.naturalWidth) return null;
    return { x: pos.x * scale - offsetX, y: pos.y * scale, w: img.naturalWidth * scale * pos.scale, h: img.naturalHeight * scale * pos.scale };
  }
  function updateButtonZones() {
    if (!bg || !bg.naturalWidth) return;
    ['left', 'right'].forEach(side => {
      let zone = document.getElementById('zone-' + side);
      if (!zone) {
        zone = document.createElement('div');
        zone.id = 'zone-' + side;
        zone.className = 'btn-zone';
        document.body.appendChild(zone);
        zone.addEventListener('click', e => {
          startAudio();
          const rect = zone.getBoundingClientRect();
          const relY = e.clientY - rect.top;
          if (relY < rect.height / 2) {
            toggleDoor(side);
          } else {
            const otherSide = side === 'left' ? 'right' : 'left';
            if (state[side].light === 'off') {
              state[side].light = 'on';
              state[otherSide].light = 'off';
              flickerTimers[otherSide].forEach(t => clearTimeout(t));
              flickerTimers[otherSide] = []; flickerOverride[otherSide] = null;
              triggerFlicker(side);
            } else {
              state[side].light = 'off';
              flickerTimers[side].forEach(t => clearTimeout(t));
              flickerTimers[side] = []; flickerOverride[side] = null;
            }
            updateLightAudio();
          }
        });
      }
      const r = getBtnScreenRect(side);
      if (r) { zone.style.left = r.x+'px'; zone.style.top = r.y+'px'; zone.style.width = r.w+'px'; zone.style.height = r.h+'px'; }
    });
  }

  let powerOut = false, renderPaused = false;

  function draw() {
    if (!bg.complete || !bg.naturalWidth) return;
    const imgW = bg.naturalWidth, imgH = bg.naturalHeight;
    const scale = H / imgH, maxOffset = (imgW * scale) - W, offsetX = scroll * maxOffset;
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
    const pof = window._powerOutEyeFrame;
    if (pof === 'black' || pof === 'jumpscare') return;
    drawStripLayer(getActiveBg(), imgW, imgH, scale, offsetX);
    if (!powerOut) drawSprite(fanFrames[fanIndex], { x: fanAnimation.imgX, y: fanAnimation.imgY, scale: fanAnimation.scale }, scale, offsetX);
    ['left', 'right'].forEach(side => {
      const anim = doorAnim[side], frames = doorFrames[side], pos = doorPos[side];
      drawSprite(frames[0], pos, scale, offsetX);
      if (anim.frameIndex > 0) drawSprite(frames[anim.frameIndex], pos, scale, offsetX);
    });
    if (!powerOut) {
      drawSprite(getBtnImg('left'),  btnPos.left,  scale, offsetX);
      drawSprite(getBtnImg('right'), btnPos.right, scale, offsetX);
      updateButtonZones();
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    if (renderPaused) return;
    if (!isDragging) { velocity *= 0.85; targetScroll += velocity; }
    targetScroll = clamp(targetScroll, 0, 1);
    scroll += (targetScroll - scroll) * 0.12;
    draw();
  }

  // ── Jumpscare player ──────────────────────────────────────────
  // FIX: added maxDurationMs as 4th param (was referenced but missing)
  function playJumpscare(def, sfxSrc, onDone, maxDurationMs) {
    if (!def) { console.warn('playJumpscare: missing animation def'); return; }
    renderPaused = true;
    const sfx = typeof sfxSrc === 'string' ? new Audio(sfxSrc) : sfxSrc;
    sfx.currentTime = 0;
    const msPerFrame = 1000 / def.fps;
    let finished = false;

    const frames = def.frames.map(src => { const img = new Image(); img.src = src; return img; });

    function finish() {
      if (finished) return;
      finished = true;
      sfx.pause(); sfx.currentTime = 0;
      if (onDone) { onDone(); } else { renderPaused = false; }
    }

    sfx.play().catch(() => {});
    if (maxDurationMs != null) setTimeout(finish, maxDurationMs);

    let frameIdx = 0;
    function nextFrame() {
      if (finished) return;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
      const img = frames[frameIdx];
      if (img.naturalWidth) {
        const sc = Math.max(W / img.naturalWidth, H / img.naturalHeight);
        const dw = img.naturalWidth * sc, dh = img.naturalHeight * sc;
        ctx.drawImage(img, (W - dw) / 2, (H - dh) / 2, dw, dh);
      }
      frameIdx++;
      if (frameIdx < frames.length) { setTimeout(nextFrame, msPerFrame); } else { finish(); }
    }
    nextFrame();
  }

  const SCREAM  = sfxScream;
  const SCREAM2 = sfxScream2;
  const NOISE   = sfxNoise;
  const JUMPSCARE_MAX_MS = 1000;

  const GO_MENU  = () => { ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); setTimeout(() => { window.location.href = 'menu.html'; }, 1500); };
  const GO_NOISE = () => { ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); setTimeout(() => { playJumpscare(noiseMenu, NOISE, GO_MENU); }, 500); };

  function playChicaJumpscare()        { playJumpscare(chicajumpscare,          SCREAM,  null,     JUMPSCARE_MAX_MS); }
  function playFoxyJumpscare()         { playJumpscare(foxyJumpscare,           SCREAM,  null,     JUMPSCARE_MAX_MS); }
  function playBonnieJumpscare()       { playJumpscare(bonnieJumpscare,         SCREAM,  null,     JUMPSCARE_MAX_MS); }
  function playFreddyJumpscare()       { playJumpscare(freddyJumpscare,         SCREAM,  null,     JUMPSCARE_MAX_MS); }
  function playGoldenFreddyJumpscare() { playJumpscare(goldenFreddyJumpscare,   SCREAM2, null,     JUMPSCARE_MAX_MS); }
  function playPowerOutJumpscare()     { playJumpscare(freddyJumpscarePowerOut, SCREAM,  GO_NOISE, JUMPSCARE_MAX_MS); }
  function playnoiseMenu()             { playJumpscare(noiseMenu,               NOISE,   GO_MENU,  JUMPSCARE_MAX_MS); }

  // --- Debug ---
  let debugVisible = false;
  window.addEventListener('keydown', e => {
    if (e.key === 'd' || e.key === 'D') {
      debugVisible = !debugVisible;
      document.getElementById('debug').style.display = debugVisible ? 'block' : 'none';
    }
    if (e.key === 'j' || e.key === 'J') {
      const picks = [playChicaJumpscare, playBonnieJumpscare, playFoxyJumpscare, playFreddyJumpscare, playGoldenFreddyJumpscare, playnoiseMenu];
      picks[Math.floor(Math.random() * picks.length)]();
    }
  });

  function bindSlider(id, valId, side, prop, isFloat) {
    document.getElementById(id).addEventListener('input', function() {
      btnPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindSlider('slx','vlx','left','x',false); bindSlider('sly','vly','left','y',false); bindSlider('slsc','vlsc','left','scale',true);
  bindSlider('srx','vrx','right','x',false); bindSlider('sry','vry','right','y',false); bindSlider('srsc','vrsc','right','scale',true);

  function bindDoorSlider(id, valId, side, prop, isFloat) {
    document.getElementById(id).addEventListener('input', function() {
      doorPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindDoorSlider('sldx','vldx','left','x',false); bindDoorSlider('sldy','vldy','left','y',false); bindDoorSlider('sldsc','vldsc','left','scale',true);
  bindDoorSlider('srdx','vrdx','right','x',false); bindDoorSlider('srdy','vrdy','right','y',false); bindDoorSlider('srdsc','vrdsc','right','scale',true);

  document.getElementById('copy-btn').addEventListener('click', () => {
    const s = [`// Buttons`,`left:  { x: ${btnPos.left.x},  y: ${btnPos.left.y},  scale: ${btnPos.left.scale.toFixed(2)} },`,`right: { x: ${btnPos.right.x}, y: ${btnPos.right.y}, scale: ${btnPos.right.scale.toFixed(2)} }`,``,`// Doors`,`left:  { imgX: ${doorPos.left.x},  imgY: ${doorPos.left.y},  scale: ${doorPos.left.scale.toFixed(2)} },`,`right: { imgX: ${doorPos.right.x}, imgY: ${doorPos.right.y}, scale: ${doorPos.right.scale.toFixed(2)} }`].join('\n');
    navigator.clipboard?.writeText(s); alert(s);
  });

  function bindHudSlider(sliderId, valId, cssVar, unit, isFloat) {
    document.getElementById(sliderId).addEventListener('input', function() {
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
      document.documentElement.style.setProperty(cssVar, this.value + unit);
    });
  }
  bindHudSlider('shtr-t','vhtr-t','--hud-tr-top','px',false);   bindHudSlider('shtr-r','vhtr-r','--hud-tr-right','px',false);
  bindHudSlider('shtr-s','vhtr-s','--hud-tr-scale','',true);
  bindHudSlider('shpw-b','vhpw-b','--hud-pw-bottom','px',false); bindHudSlider('shpw-l','vhpw-l','--hud-pw-left','px',false);
  bindHudSlider('shus-b','vhus-b','--hud-us-bottom','px',false); bindHudSlider('shus-l','vhus-l','--hud-us-left','px',false);
  bindHudSlider('shbl-s','vhbl-s','--hud-bl-scale','',true);

  document.getElementById('copy-hud-btn').addEventListener('click', () => {
    const v = id => document.getElementById(id).value;
    const s = [`/* Top-Right */`,`--hud-tr-top:    ${v('shtr-t')}px`,`--hud-tr-right:  ${v('shtr-r')}px`,`--hud-tr-scale:  ${v('shtr-s')}`,`/* Power Left */`,`--hud-pw-bottom: ${v('shpw-b')}px`,`--hud-pw-left:   ${v('shpw-l')}px`,`/* Usage/Battery */`,`--hud-us-bottom: ${v('shus-b')}px`,`--hud-us-left:   ${v('shus-l')}px`,`--hud-bl-scale:  ${v('shbl-s')}`].join('\n');
    navigator.clipboard?.writeText(s); alert(s);
  });

  // --- Tablet audio ---
  const sfxCameraUp   = new Audio('../Assets/FNaF 1 Audio/CAMERA_VIDEO_LOA_60105303.wav');
  const sfxCameraDown = new Audio('../Assets/FNaF 1 Audio/put down.wav');
  const sfxCameraLoop = new Audio('../Assets/FNaF 1 Audio/MiniDV_Tape_Eject_1.wav');
  sfxCameraUp.volume = 0.5; sfxCameraDown.volume = 0.5;
  sfxCameraLoop.loop = true; sfxCameraLoop.volume = 0.4;

  // --- Tablet animation frames ---
  const tabletFrames = [];
  for (let i = 1; i <= tabletAnimation.frameCount; i++) {
    const img = new Image(); img.src = `${tabletAnimation.basePath}${i}.png`; tabletFrames.push(img);
  }

  // --- DOM refs (declared ONCE) ---
  const tabletBar    = document.getElementById('tablet-bar');
  const tabletCanvas = document.getElementById('tablet-anim-canvas');
  const tabletCtx    = tabletCanvas.getContext('2d');
  const tabletCam    = document.getElementById('tablet-cam');
  tabletCam.width    = window.innerWidth;
  tabletCam.height   = window.innerHeight;
  const camCtx       = tabletCam.getContext('2d');

  window.addEventListener('resize', () => {
    tabletCam.width  = window.innerWidth;
    tabletCam.height = window.innerHeight;
  });

  // --- Camera source — supports both .mp4 and image files ---
  const camVideo = document.createElement('video');
  camVideo.loop = true; camVideo.muted = true; camVideo.playsInline = true; camVideo.preload = 'auto';

  let camImageEl = new Image();
  let camSrcIsVideo = false;

  function setCamSrc(src) {
    const isVideo = /\.(mp4|webm|ogg)$/i.test(src);
    camSrcIsVideo = isVideo;
    if (isVideo) {
      camVideo.src = src;
      camAudio.src = src;
      camImageEl = new Image(); // clear image
    } else {
      const img = new Image();
      img.src = src;
      camImageEl = img;
      camVideo.src = '';
      camAudio.src = '';
    }
  }

  const camAudio = document.createElement('audio');
  camAudio.loop = true; camAudio.volume = 0.8; camAudio.preload = 'auto';

  // Set initial source here — swap this one line to change camera
  setCamSrc('../Assets/Freddy/agnes.mp4');

  function camReady() {
    if (camSrcIsVideo) return camVideo.readyState >= 2 && camVideo.videoWidth > 0;
    return camImageEl.complete && camImageEl.naturalWidth > 0;
  }
  function camWidth()  { return camSrcIsVideo ? camVideo.videoWidth  : camImageEl.naturalWidth;  }
  function camHeight() { return camSrcIsVideo ? camVideo.videoHeight : camImageEl.naturalHeight; }
  function camSource() { return camSrcIsVideo ? camVideo : camImageEl; }

  function startCamVideo() {
    if (!camSrcIsVideo) return;
    camVideo.currentTime = 0; camAudio.currentTime = 0;
    camVideo.play().catch(() => {}); camAudio.play().catch(() => {});
  }
  function stopCamVideo() {
    camVideo.pause(); camVideo.currentTime = 0;
    camAudio.pause(); camAudio.currentTime = 0;
  }

  // --- noiseMenu overlay ---
  let noiseMenuFrames = [], noiseMenuReady = false;
  (function preloadNoiseFrames() {
    let loaded = 0;
    const srcs = noiseMenu.frames;
    noiseMenuFrames = srcs.map(src => {
      const img = new Image();
      img.onload = img.onerror = () => { loaded++; if (loaded === srcs.length) noiseMenuReady = true; };
      img.src = src; return img;
    });
  })();

  let noiseIndex = 0, noiseRafId = null, noiseLastTime = 0, noiseAccum = 0;
  const noiseMsPerFrame = 1000 / noiseMenu.fps;

  // --- Camera pan ---
  let camPan = 0, camPanDir = 1;
  const CAM_PAN_SPEED = 0.000065;

  // --- Camera GUI overlay ---
  const camFrameImg  = new Image(); camFrameImg.src  = '../Assets/Cam_views/11.png';
  const camRedDotImg = new Image(); camRedDotImg.src = '../Assets/Cam_views/7.png';

  const RED_DOT_ON = 900, RED_DOT_OFF = 400, RED_DOT_PERIOD = 1300;
  function isRedDotVisible() { return (performance.now() % RED_DOT_PERIOD) < RED_DOT_ON; }

  function drawCamView() {
    const cw = tabletCam.width, ch = tabletCam.height;
    camCtx.fillStyle = '#000'; camCtx.fillRect(0, 0, cw, ch);

    if (camReady()) {
      const imgW = camWidth(), imgH = camHeight();
      if (camSrcIsVideo) {
        // Video: cover-fill, centered
        const scale = Math.max(cw / imgW, ch / imgH);
        const dw = imgW * scale, dh = imgH * scale;
        camCtx.drawImage(camSource(), (cw - dw) / 2, (ch - dh) / 2, dw, dh);
      } else {
        // Image: strip-based fisheye pan (left ↔ right)
        // Scale so image fills height OR width — whichever makes it wider than the screen
        const scaleH = ch / imgH;
        const scaleW = cw / imgW;
        const scale  = Math.max(scaleH, scaleW * 1.4); // 1.4x ensures panning room even on wide images
        const maxOffset = (imgW * scale) - cw;
        const offsetX = camPan * Math.max(0, maxOffset);
        for (let sx = 0; sx < cw; sx++) {
          const imgX = (offsetX + sx) / scale;
          if (imgX < 0 || imgX >= imgW) continue;
          const screenNorm = (sx / cw - 0.5) * 2;
          const dist = Math.sqrt(1 + (screenNorm * FOV_FACTOR) ** 2);
          const stripH = ch / dist;
          camCtx.drawImage(camSource(), imgX, 0, 1, imgH, sx, (ch - stripH) / 2, 1, stripH);
        }
      }
    }

    const noiseFrame = noiseMenuReady ? noiseMenuFrames[noiseIndex] : null;
    if (noiseFrame && noiseFrame.complete && noiseFrame.naturalWidth) {
      camCtx.save();
      camCtx.globalCompositeOperation = 'screen';
      camCtx.globalAlpha = 0.55;
      const scale = Math.max(cw / noiseFrame.naturalWidth, ch / noiseFrame.naturalHeight);
      camCtx.drawImage(noiseFrame, (cw - noiseFrame.naturalWidth * scale) / 2, (ch - noiseFrame.naturalHeight * scale) / 2, noiseFrame.naturalWidth * scale, noiseFrame.naturalHeight * scale);
      camCtx.restore();
    }

    if (camFrameImg.complete && camFrameImg.naturalWidth) camCtx.drawImage(camFrameImg, 0, 0, cw, ch);

    if (isRedDotVisible() && camRedDotImg.complete && camRedDotImg.naturalWidth) {
      const dotH = ch * 0.07, dotW = camRedDotImg.naturalWidth * (dotH / camRedDotImg.naturalHeight);
      camCtx.drawImage(camRedDotImg, cw * 0.02, ch * 0.03, dotW, dotH);
    }
  }

  function tickNoise(timestamp) {
    if (tabletCam.style.display === 'none') { noiseRafId = null; return; }
    const delta = noiseLastTime ? timestamp - noiseLastTime : 0;
    noiseLastTime = timestamp;
    noiseAccum += delta;
    while (noiseAccum >= noiseMsPerFrame) { noiseAccum -= noiseMsPerFrame; noiseIndex = (noiseIndex + 1) % noiseMenuFrames.length; }
    camPan += camPanDir * CAM_PAN_SPEED * delta;
    if (camPan >= 1) { camPan = 1; camPanDir = -1; }
    if (camPan <= 0) { camPan = 0; camPanDir =  1; }
    drawCamView();
    noiseRafId = requestAnimationFrame(tickNoise);
  }
  function startNoiseLoop() { if (noiseRafId) return; noiseLastTime = 0; noiseRafId = requestAnimationFrame(tickNoise); }
  function stopNoiseLoop()  { if (noiseRafId) { cancelAnimationFrame(noiseRafId); noiseRafId = null; } }

  // --- Tablet state ---
  let tabletState = 'closed', tabletFrame = 0, lastFrameTime = 0;

  function resizeTabletCanvas() { tabletCanvas.width = window.innerWidth; tabletCanvas.height = window.innerHeight; }
  resizeTabletCanvas();
  window.addEventListener('resize', resizeTabletCanvas);

  function drawTabletFrame(idx) {
    const img = tabletFrames[idx];
    if (!img.complete || !img.naturalWidth) return;
    tabletCtx.clearRect(0, 0, tabletCanvas.width, tabletCanvas.height);
    const scale = Math.max(tabletCanvas.width / img.naturalWidth, tabletCanvas.height / img.naturalHeight);
    const dw = img.naturalWidth * scale, dh = img.naturalHeight * scale;
    tabletCtx.drawImage(img, (tabletCanvas.width - dw) / 2, (tabletCanvas.height - dh) / 2, dw, dh);
  }

  function animateTablet(timestamp) {
    if (tabletState !== 'opening' && tabletState !== 'closing') return;
    if (timestamp - lastFrameTime > tabletAnimation.frameDelay) {
      lastFrameTime = timestamp;
      if (tabletState === 'opening') {
        drawTabletFrame(tabletFrame);
        tabletFrame++;
        if (tabletFrame >= tabletFrames.length) {
          tabletState = 'waiting';
          setTimeout(() => {
            tabletCanvas.style.display = 'none';
            tabletCam.style.display    = 'block';
            tabletBar.style.display    = 'none';
            tabletState = 'open';
            startNoiseLoop();
            startCamVideo();
            sfxCameraLoop.currentTime = 0;
            sfxCameraLoop.play().catch(() => {});
          }, tabletAnimation.frameDelay);
          return;
        }
      } else if (tabletState === 'closing') {
        tabletFrame--;
        if (tabletFrame < 0) {
          stopNoiseLoop();
          tabletCanvas.style.display = 'none';
          tabletCam.style.display    = 'none';
          tabletState = 'closed';
          canvas.style.display = 'block';
          tabletBar.style.display = 'flex';
          document.querySelectorAll('.btn-zone').forEach(z => z.style.display = 'block');
          return;
        }
        drawTabletFrame(tabletFrame);
      }
    }
    requestAnimationFrame(animateTablet);
  }

  function openTablet() {
    if (tabletState !== 'closed') return;
    if (GameState.rawPower <= 0) return;
    sfxCameraUp.currentTime = 0; sfxCameraUp.play().catch(() => {});
    tabletState = 'opening'; tabletFrame = 0;
    tabletCanvas.style.display = 'block';
    tabletCanvas.width  = window.innerWidth;
    tabletCanvas.height = window.innerHeight;
    requestAnimationFrame(animateTablet);
  }

  function closeTablet() {
    if (tabletState !== 'open') return;
    sfxCameraDown.currentTime = 0; sfxCameraDown.play().catch(() => {});
    sfxCameraLoop.pause(); sfxCameraLoop.currentTime = 0;
    stopCamVideo();
    stopNoiseLoop();
    tabletState = 'closing';
    tabletFrame = tabletFrames.length - 1;
    tabletCam.style.display    = 'none';
    tabletCanvas.style.display = 'block';
    drawTabletFrame(tabletFrame);
    requestAnimationFrame(animateTablet);
  }

  tabletBar.addEventListener('click', openTablet);
  window.addEventListener('mousemove', e => {
    const fromBottom = window.innerHeight - e.clientY;
    if (fromBottom < 60 && tabletState === 'closed') openTablet();
    if (fromBottom < 60 && tabletState === 'open')   closeTablet();
  });

  // --- Mouse/touch pan ---
  canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; velocity = 0; document.body.classList.add('dragging'); startAudio(); });
  window.addEventListener('mousemove', e => { if (!isDragging) return; const dx = e.clientX - lastX; const scale = H / bg.naturalHeight; const maxOffset = (bg.naturalWidth * scale) - W; velocity = -(dx / maxOffset); targetScroll += velocity; lastX = e.clientX; });
  window.addEventListener('mouseup', () => { isDragging = false; document.body.classList.remove('dragging'); });
  canvas.addEventListener('touchstart', e => { isDragging = true; lastX = e.touches[0].clientX; velocity = 0; e.preventDefault(); }, { passive: false });
  window.addEventListener('touchmove', e => { if (!isDragging) return; const dx = e.touches[0].clientX - lastX; const scale = H / bg.naturalHeight; const maxOffset = (bg.naturalWidth * scale) - W; velocity = -(dx / maxOffset); targetScroll += velocity; lastX = e.touches[0].clientX; e.preventDefault(); }, { passive: false });
  window.addEventListener('touchend', () => { isDragging = false; });

  window.addEventListener('load', () => {
    const fadeEl = document.getElementById('page-fade');
    requestAnimationFrame(() => requestAnimationFrame(() => { fadeEl.style.opacity = '0'; }));
  });

  // ── GameState ──────────────────────────────────────────────────
  const HOURS = ['12 AM','1 AM','2 AM','3 AM','4 AM','5 AM','6 AM'];
  const NIGHT_SECS = 535, SECS_PER_HOUR = NIGHT_SECS / 6;
  const PASSIVE_INTERVAL = { 1: 0, 2: 6, 3: 5, 4: 4, 5: 3, 6: 3, 7: 3 };

  const GameState = {
    night: 1, rawPower: 999, secondsElapsed: 0, passiveAccum: 0,

    getUsage() {
      let u = 1;
      if (state.left.door  === 'closed') u++;
      if (state.right.door === 'closed') u++;
      if (state.left.light === 'on')     u++;
      if (state.right.light === 'on')    u++;
      return Math.min(u, 5);
    },

    tick() {
      if (this.rawPower <= 0) { this.rawPower = 0; this.render(); this.onPowerOut(); return; }
      this.rawPower -= this.getUsage();
      const interval = PASSIVE_INTERVAL[this.night] || 0;
      if (interval > 0) { this.passiveAccum++; if (this.passiveAccum >= interval) { this.passiveAccum = 0; this.rawPower--; } }
      this.rawPower = Math.max(0, this.rawPower);
      this.secondsElapsed++;
      if (this.secondsElapsed >= NIGHT_SECS) { this.on6AM(); return; }
      this.render();
    },

    getDisplayPercent() { return (Math.round(this.rawPower) / 10).toFixed(1); },
    getCurrentHour()    { return Math.min(6, Math.floor(this.secondsElapsed / SECS_PER_HOUR)); },

    render() {
      const usage = this.getUsage();
      document.getElementById('hud-night').textContent     = `Night ${this.night}`;
      document.getElementById('hud-time').textContent      = HOURS[this.getCurrentHour()];
      document.getElementById('hud-power-val').textContent = `${this.getDisplayPercent()}%`;
      const batteryMap = { 1: '212', 2: '213', 3: '214', 4: '456', 5: '455' };
      document.getElementById('hud-battery-img').src = `../Assets/Battery/${batteryMap[usage] || '212'}.png`;
    },

    onPowerOut() {
      if (this._powerOutTriggered) return;
      this._powerOutTriggered = true;
      powerOut = true;
      window._powerOutEyeFrame = '304';
      document.getElementById('hud-top-right').style.display = 'none';
      document.getElementById('hud-power').style.display     = 'none';
      document.getElementById('hud-usage').style.display     = 'none';
      document.getElementById('tablet-bar').style.display    = 'none';
      document.querySelectorAll('.btn-zone').forEach(z => z.style.display = 'none');
      [sfxFan, sfxPhone, sfxLight, sfxCameraLoop, camAudio].forEach(a => { a.pause(); a.currentTime = 0; });
      stopCamVideo();
      ['left', 'right'].forEach(side => { state[side].door = 'open'; state[side].light = 'off'; startDoorAnim(side, -1); });

      const powerOutsfx = new Audio('../Assets/FNaF 1 Audio/powerdown.wav');
      powerOutsfx.play().catch(() => {});

      setTimeout(() => {
        const steps1 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
        steps1.volume = 0.15; steps1.play().catch(() => {});
        steps1.addEventListener('ended', () => {
          const steps2 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
          steps2.volume = 0.45; steps2.play().catch(() => {});
          setTimeout(() => {
            const steps3 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
            steps3.volume = 0.85; steps3.play().catch(() => {});
            steps3.addEventListener('ended', () => {
              const musicBox = new Audio('../Assets/FNaF 1 Audio/music box.wav');
              window._powerOutEyeFrame = '304';
              const schedule = [];
              const flickerPattern = (() => {
                const pattern = [];
                function addPhase1(startT, duration) { let t = startT; while (t < startT + duration) { pattern.push({ img: '305', t }); t += 50; pattern.push({ img: '304', t }); t += 25; } return t; }
                function addPhase2(startT, duration) { let t = startT; while (t < startT + duration) { pattern.push({ img: '305', t }); t += 250; pattern.push({ img: '304', t }); t += 150; } return t; }
                function addPhase2Fast(startT, duration) { let t = startT; while (t < startT + duration) { pattern.push({ img: '305', t }); t += 100; pattern.push({ img: '304', t }); t += 80; } return t; }
                let t = 200;
                t = addPhase2(t, 4000); t = addPhase1(t, 1500); t = addPhase2(t, 1200); t = addPhase1(t, 1000);
                t += 200; t = addPhase2(t, 1000); t = addPhase1(t, 1500); t += 200; t = addPhase2(t, 2000);
                t = addPhase1(t, 1500); t = addPhase2(t, 1200); t = addPhase1(t, 1000); t = addPhase2Fast(t, 3000);
                return pattern.sort((a, b) => a.t - b.t);
              })();
              flickerPattern.forEach(e => schedule.push(e));
              schedule.sort((a, b) => a.t - b.t);
              schedule.forEach(({ img, t }) => setTimeout(() => { window._powerOutEyeFrame = img; }, t));
              musicBox.play().catch(() => {});
              setTimeout(() => {
                musicBox.pause();
                window._powerOutEyeFrame = 'black';
                const sequence = [
                  { play: true, duration: 100 }, { play: false, duration: 50 },
                  { play: true, duration: 80  }, { play: false, duration: 50 },
                  { play: true, duration: 120 }, { play: false, duration: 100 },
                ];
                let t = 0;
                sequence.forEach(({ play, duration }) => {
                  setTimeout(() => {
                    if (play) {
                      const buzz = new Audio('../Assets/FNaF 1 Audio/Buzz_Fan_Florescent2.wav');
                      buzz.volume = 1; buzz.play().catch(() => {});
                      setTimeout(() => buzz.pause(), duration);
                      window._powerOutEyeFrame = '304';
                    } else { window._powerOutEyeFrame = 'black'; }
                  }, t);
                  t += duration;
                });
                setTimeout(() => {
                  window._powerOutEyeFrame = 'black';
                  const steps4 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
                  steps4.volume = 1; steps4.play().catch(() => {});
                  steps4.addEventListener('ended', () => { window._powerOutEyeFrame = 'jumpscare'; playPowerOutJumpscare(); });
                }, 500);
              }, 20000);
            });
          }, 4000);
        });
      }, 3000);
    },

    on6AM() { console.log('6 AM — night complete'); },
  };

  setInterval(() => GameState.tick(), 1000);
  GameState.render();
</script>
</body>
</html>