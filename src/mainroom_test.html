<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FNAF Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    @font-face {
      font-family: 'FNAF';
      src: url('../Assets/Fonts/five-nights-at-freddys.otf') format('opentype');
    }

    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      cursor: grab;
      user-select: none;
    }
    body.dragging { cursor: grabbing; }
    canvas { display: block; position: absolute; top: 0; left: 0; }

    /* ── HUD ──────────────────────────────────────────────────── */
    #hud {
      position: fixed;
      bottom: 52px; /* sit above tablet bar */
      left: 20px;
      z-index: 500;
      pointer-events: none;
      user-select: none;
      font-family: 'FNAF', 'Courier New', monospace;
      font-size: clamp(10px, 1.3vw, 17px);
      color: #5dff5d;
      text-shadow: 0 0 8px #00cc00;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #hud-night {
      font-size: clamp(12px, 1.6vw, 21px);
      letter-spacing: 0.05em;
    }

    #hud-time {
      font-size: clamp(11px, 1.5vw, 20px);
      letter-spacing: 0.08em;
    }

    #hud-power-label {
      margin-top: 6px;
    }

    #hud-power-bar-track {
      width: clamp(80px, 10vw, 140px);
      height: 8px;
      background: #1a3d1a;
      border: 1px solid #2a6a2a;
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }

    #hud-power-bar-fill {
      height: 100%;
      background: #5dff5d;
      box-shadow: 0 0 6px #00cc00;
      transition: width 1s linear, background 1s;
      border-radius: 2px;
    }

    #hud-power-bar-fill.low   { background: #ffaa00; box-shadow: 0 0 6px #cc8800; }
    #hud-power-bar-fill.critical { background: #ff3333; box-shadow: 0 0 6px #cc0000; }

    #hud-usage {
      margin-top: 3px;
      letter-spacing: 0.12em;
    }

    /* Page fade-in on load */
    #page-fade {
      position: fixed;
      inset: 0;
      z-index: 998;
      background: #000;
      opacity: 1;
      pointer-events: none;
      transition: opacity 0.9s ease;
    }

    /* Invisible click zones for buttons — positioned by JS */
    .btn-zone {
      position: absolute;
      cursor: pointer;
      z-index: 10;
    }

    #debug {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.88);
      color: #0f0;
      font: 11px monospace;
      padding: 12px;
      border: 1px solid #0f0;
      z-index: 600;
      width: 240px;
    }
    #debug label { display: block; margin-top: 6px; }
    #debug input[type=range] { width: 100%; }
    #debug .val { color: #ff0; float: right; }
    #debug h3 { color: #0f0; margin-bottom: 2px; }
    #debug h4 { color: #aaffaa; margin-top: 8px; margin-bottom: 2px; }
    #debug .hint { color: #888; font-size: 10px; margin-top: 6px; }
    #copy-btn { margin-top: 8px; width: 100%; background: #0a0; color: #fff; border: none; padding: 4px; cursor: pointer; font: 11px monospace; }

    /* Tablet bar */
    #tablet-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40px;
      background: #1a1a1a;
      border-top: 2px solid #333;
      z-index: 550;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #tablet-bar img {
      height: 30px;
      opacity: 0.7;
    }
    #tablet-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      display: none;
      background: #000;
    }
    #tablet-overlay canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: contain;
    }
    #tablet-cam {
      position: fixed;
      inset: 0;
      z-index: 41;
      display: none;
      background: #000;
    }
    #tablet-cam img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="page-fade"></div>

<!-- HUD -->
<div id="hud">
  <div id="hud-night">Night 1</div>
  <div id="hud-time">12 AM</div>
  <div id="hud-power-label">Power Left: <span id="hud-power-val">99%</span></div>
  <div id="hud-power-bar-track">
    <div id="hud-power-bar-fill" style="width:99%"></div>
  </div>
  <div id="hud-usage">Usage: <span id="hud-usage-val">█░░░░</span></div>
</div>
<div id="debug">
  <h3>Debug [D to hide]</h3>
  <h4>Left Button</h4>
  <label>X: <span class="val" id="vlx">0</span>
    <input type="range" id="slx" min="0" max="3000" value="0">
  </label>
  <label>Y: <span class="val" id="vly">261</span>
    <input type="range" id="sly" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vlsc">1.00</span>
    <input type="range" id="slsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Button</h4>
  <label>X: <span class="val" id="vrx">1478</span>
    <input type="range" id="srx" min="0" max="3000" value="1478">
  </label>
  <label>Y: <span class="val" id="vry">261</span>
    <input type="range" id="sry" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vrsc">1.00</span>
    <input type="range" id="srsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Left Door</h4>
  <label>X: <span class="val" id="vldx">73</span>
    <input type="range" id="sldx" min="-500" max="3000" value="73">
  </label>
  <label>Y: <span class="val" id="vldy">41</span>
    <input type="range" id="sldy" min="-500" max="1500" value="41">
  </label>
  <label>Scale: <span class="val" id="vldsc">1.00</span>
    <input type="range" id="sldsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Door</h4>
  <label>X: <span class="val" id="vrdx">1263</span>
    <input type="range" id="srdx" min="-500" max="3000" value="1263">
  </label>
  <label>Y: <span class="val" id="vrdy">31</span>
    <input type="range" id="srdy" min="-500" max="1500" value="31">
  </label>
  <label>Scale: <span class="val" id="vrdsc">1.00</span>
    <input type="range" id="srdsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <div class="hint">Coords in source image pixels.</div>
  <button id="copy-btn">Copy values</button>
</div>

<div id="tablet-bar">
  <img src="../Assets/Tablette/open_tablette_icon.png" alt="tablet">
</div>
<canvas id="tablet-anim-canvas" style="display:none;position:fixed;inset:0;width:100%;height:100%;z-index:45;"></canvas>
<div id="tablet-cam" style="display:none;position:fixed;inset:0;z-index:44;background:#000;">
  <img src="../Assets/Cam_views/188.png" style="width:100%;height:100%;object-fit:contain;">
</div>

<!-- Animation data must load before the main script -->
<script src="animations.js"></script>
<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H;
  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // --- Audio ---
  const audioBase = '../Assets/FNaF 1 Audio/';
  const sfxFan = new Audio(audioBase + 'Buzz_Fan_Florescent2.wav');
  sfxFan.loop = true; sfxFan.volume = 0.1;
  const sfxPhone = new Audio(audioBase + 'voiceover1c.wav');
  sfxPhone.volume = 0.5;
  const ambienceSrcs = [audioBase + 'ambience2.wav', audioBase + 'EerieAmbienceLargeSca_MV005.wav'];
  let audioStarted = false;

  function startAudio() {
    if (audioStarted) return;
    audioStarted = true;
    sfxFan.play().catch(() => {});
    sfxPhone.play().catch(() => {});
    function nextAmbience() {
      const a = new Audio(ambienceSrcs[Math.floor(Math.random() * ambienceSrcs.length)]);
      a.volume = 0.4;
      a.play().catch(() => {});
      a.addEventListener('ended', nextAmbience);
    }
    nextAmbience();
  }
  window.onload = () => {
    startAudio();
  }

  // --- Background images ---
  const bg = new Image();
  bg.src = '../assets/Main Room/39.png';

  const bgLit = {
    left:  new Image(),
    right: new Image(),
  };
  bgLit.left.src  = '../Assets/Main Room/main_room_left_open_lit.png';
  bgLit.right.src = '../Assets/Main Room/main_room_right_open_lit.png';

  const bgPoweredDown = new Image();
  bgPoweredDown.src = '../Assets/Main Room/304.png';

  const bgFreddyEyesImg = new Image();
  bgFreddyEyesImg.src = '../Assets/Main Room/305.png';

  // ── Light flicker state ───────────────────────────────────────
  // When a light is first turned on, we run a short flicker sequence
  // that alternates between the dark and lit background before settling
  // on the lit image. Each entry in the sequence is { lit: bool, delay: ms }.
  const FLICKER_SEQUENCE = [
    { lit: true,  delay: 40  },
    { lit: false, delay: 60  },
    { lit: true,  delay: 30  },
    { lit: false, delay: 80  },
    { lit: true,  delay: 50  },
    { lit: false, delay: 45  },
    { lit: true,  delay: 120 },
    { lit: false, delay: 35  },
    { lit: true,  delay: 0   },  // stay on — flicker done
  ];

  // Per-side flicker state: null means no flicker active, 'on'/'off' overrides the lit bg
  const flickerOverride = { left: null, right: null };
  let flickerTimers = { left: [], right: [] };

  function triggerFlicker(side) {
    // Cancel any in-progress flicker on this side
    flickerTimers[side].forEach(t => clearTimeout(t));
    flickerTimers[side] = [];
    flickerOverride[side] = null;

    let cumulative = 0;
    FLICKER_SEQUENCE.forEach(({ lit, delay }, i) => {
      const t = setTimeout(() => {
        const isLast = (i === FLICKER_SEQUENCE.length - 1);
        if (state[side].light === 'on') {
          flickerOverride[side] = isLast ? null : (lit ? 'on' : 'off');
        } else {
          flickerOverride[side] = null;
        }
        // Keep audio in sync with whatever the visual is doing this step
        updateLightAudio();
      }, cumulative);
      flickerTimers[side].push(t);
      cumulative += delay;
    });
  }

  function getActiveBg() {
    // Eye-sequence override
    if (window._powerOutEyeFrame === '305') {
      return bgFreddyEyesImg.complete && bgFreddyEyesImg.naturalWidth ? bgFreddyEyesImg : bgPoweredDown;
    }
    if (powerOut) {
      return bgPoweredDown.complete && bgPoweredDown.naturalWidth ? bgPoweredDown : bg;
    }

    const leftLit  = state.left.light  === 'on';
    const rightLit = state.right.light === 'on';

    // Apply per-side flicker overrides: 'off' forces dark bg even if light is on
    const leftEffective  = leftLit  && flickerOverride.left  !== 'off';
    const rightEffective = rightLit && flickerOverride.right !== 'off';

    if (leftEffective  && !rightEffective) return bgLit.left.complete  && bgLit.left.naturalWidth  ? bgLit.left  : bg;
    if (rightEffective && !leftEffective)  return bgLit.right.complete && bgLit.right.naturalWidth ? bgLit.right : bg;
    // Both lit at once isn't normal gameplay but fall back to base bg
    return bg;
  }

  // --- Fan (loaded from fanAnimation defined in animations.js) ---
  const fanFrames = fanAnimation.frames.map(src => {
    const img = new Image();
    img.src = src;
    return img;
  });
  let fanIndex  = 0;
  let fanLoaded = 0;
  fanFrames.forEach(f => {
    f.onload  = () => { fanLoaded++; if (fanLoaded === fanFrames.length) setInterval(() => { fanIndex = (fanIndex + 1) % fanFrames.length; }, 1000 / fanAnimation.fps); };
    f.onerror = () => { fanLoaded++; };
  });

  // --- Doors (loaded from mainRoomDoorLeft/Right defined in animations.js) ---
  const sfxDoor = new Audio('../Assets/FNaF 1 Audio/SFXBible_12478.wav');
  sfxDoor.volume = 0.8;

  const sfxLight = new Audio('../Assets/FNaF 1 Audio/BallastHumMedium2.wav');
  sfxLight.loop = true;
  sfxLight.volume = 0.6;

  function updateLightAudio() {
    // Audibly on only when the visual is also showing the lit bg —
    // i.e. state is 'on' AND the flicker override isn't suppressing it.
    const leftOn  = state.left.light  === 'on' && flickerOverride.left  !== 'off';
    const rightOn = state.right.light === 'on' && flickerOverride.right !== 'off';
    if (leftOn || rightOn) {
      if (sfxLight.paused) sfxLight.play().catch(() => {});
    } else {
      sfxLight.pause();
      sfxLight.currentTime = 0;
    }
  }

  function loadDoorFrames(animDef) {
    return animDef.frames.map(src => {
      const img = new Image();
      img.src = src;
      img.onerror = () => console.warn('Missing door frame:', src);
      return img;
    });
  }

  const doorFrames = {
    left:  loadDoorFrames(mainRoomDoorLeft),
    right: loadDoorFrames(mainRoomDoorRight),
  };

  // Per-door animation state
  const doorAnim = {
    left:  { frameIndex: 0, direction: 0, timer: null },
    right: { frameIndex: 0, direction: 0, timer: null },
  };

  function stepDoor(side) {
    const anim   = doorAnim[side];
    const frames = doorFrames[side];
    anim.frameIndex += anim.direction;

    if (anim.frameIndex >= frames.length) {
      anim.frameIndex = frames.length - 1;
      anim.direction  = 0;
      clearInterval(anim.timer); anim.timer = null;
      state[side].door = 'closed';
    } else if (anim.frameIndex <= 0) {
      anim.frameIndex = 0;
      anim.direction  = 0;
      clearInterval(anim.timer); anim.timer = null;
      state[side].door = 'open';
    }
  }

  function startDoorAnim(side, direction) {
    const anim = doorAnim[side];
    const def  = side === 'left' ? mainRoomDoorLeft : mainRoomDoorRight;
    if (anim.direction === direction) return;
    anim.direction = direction;
    if (anim.timer) { clearInterval(anim.timer); anim.timer = null; }
    anim.timer = setInterval(() => stepDoor(side), 1000 / def.fps);
  }

  function toggleDoor(side) {
    const anim = doorAnim[side];
    sfxDoor.currentTime = 0;
    sfxDoor.play().catch(() => {});
    if (anim.direction === 1 || (anim.direction === 0 && anim.frameIndex === doorFrames[side].length - 1)) {
      startDoorAnim(side, -1); // open
    } else {
      startDoorAnim(side, 1);  // close
    }
  }

  // --- Button images ---
  const btnBase = '../Assets/Door_Buttons/';
  function loadBtn(side, light, door) {
    const img = new Image();
    img.src = `${btnBase}Button_${side}_light_${light}_${door}.png`;
    return img;
  }

  const btnImgs = {
    left: {
      off_closed: loadBtn('left',  'off', 'closed'),
      off_open:   loadBtn('left',  'off', 'open'),
      on_closed:  loadBtn('left',  'on',  'closed'),
      on_open:    loadBtn('left',  'on',  'open'),
    },
    right: {
      off_closed: loadBtn('right', 'off', 'closed'),
      off_open:   loadBtn('right', 'off', 'open'),
      on_closed:  loadBtn('right', 'on',  'closed'),
      on_open:    loadBtn('right', 'on',  'open'),
    }
  };

  // Button states
  const state = {
    left:  { door: 'closed', light: 'off' },
    right: { door: 'closed', light: 'off' },
  };

  function getBtnImg(side) {
    const s = state[side];
    return btnImgs[side][`${s.light}_${s.door}`];
  }

  [...Object.values(btnImgs.left), ...Object.values(btnImgs.right)].forEach(img => {
    img.onerror = () => { console.warn('Missing:', img.src); };
  });

  bg.onload = () => requestAnimationFrame(animate);

  // --- Pan ---
  let scroll = 0.5;
  let targetScroll = 0.5;
  let isDragging = false;
  let lastX = 0;
  let velocity = 0;

  // Button positions (image-space)
  let btnPos = {
    left:  { x: 0,    y: 261, scale: 1.0 },
    right: { x: 1478, y: 261, scale: 1.0 },
  };

  // Door positions (image-space)
  let doorPos = {
    left:  { x: mainRoomDoorLeft.imgX,  y: mainRoomDoorLeft.imgY,  scale: mainRoomDoorLeft.scale  },
    right: { x: mainRoomDoorRight.imgX, y: mainRoomDoorRight.imgY, scale: mainRoomDoorRight.scale },
  };

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  const FOV_FACTOR = 0.35;

  function drawStripLayer(img, imgW, imgH, scale, offsetX) {
    for (let sx = 0; sx < W; sx++) {
      const imgX = (offsetX + sx) / scale;
      if (imgX < 0 || imgX >= imgW) continue;
      const screenNorm = (sx / W - 0.5) * 2;
      const dist = Math.sqrt(1 + (screenNorm * FOV_FACTOR) ** 2);
      const stripH = H / dist;
      const yOff = (H - stripH) / 2;
      ctx.drawImage(img, imgX, 0, 1, imgH, sx, yOff, 1, stripH);
    }
  }

  function drawSprite(img, imgSpace, scale, offsetX) {
    if (!img.complete || !img.naturalWidth) return;
    const sx = imgSpace.x * scale - offsetX;
    const sy = imgSpace.y * scale;
    const dw = img.naturalWidth  * scale * imgSpace.scale;
    const dh = img.naturalHeight * scale * imgSpace.scale;
    ctx.drawImage(img, sx, sy, dw, dh);
  }

  function getBtnScreenRect(side) {
    if (!bg || !bg.complete || !bg.naturalWidth) return null;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    const offsetX = scroll * maxOffset;
    const pos = btnPos[side];
    const img = getBtnImg(side);
    if (!img.complete || !img.naturalWidth) return null;
    return {
      x: pos.x * scale - offsetX,
      y: pos.y * scale,
      w: img.naturalWidth  * scale * pos.scale,
      h: img.naturalHeight * scale * pos.scale,
    };
  }

  function updateButtonZones() {
    if (!bg || !bg.naturalWidth) return;
    ['left', 'right'].forEach(side => {
      let zone = document.getElementById('zone-' + side);
      if (!zone) {
        zone = document.createElement('div');
        zone.id = 'zone-' + side;
        zone.className = 'btn-zone';
        document.body.appendChild(zone);

        zone.addEventListener('click', e => {
          startAudio();
          const rect = zone.getBoundingClientRect();
          const relY = e.clientY - rect.top;
          if (relY < rect.height / 2) {
            toggleDoor(side);
          } else {
            const otherSide = side === 'left' ? 'right' : 'left';
            if (state[side].light === 'off') {
              // Turn this light on, force the other off
              state[side].light = 'on';
              state[otherSide].light = 'off';
              // Cancel any flicker on the other side since it's turning off
              flickerTimers[otherSide].forEach(t => clearTimeout(t));
              flickerTimers[otherSide] = [];
              flickerOverride[otherSide] = null;
              // Trigger flicker on the newly-lit side
              triggerFlicker(side);
            } else {
              state[side].light = 'off';
              // Cancel flicker if the light is turned off mid-flicker
              flickerTimers[side].forEach(t => clearTimeout(t));
              flickerTimers[side] = [];
              flickerOverride[side] = null;
            }
            updateLightAudio();
          }
        });
      }

      const r = getBtnScreenRect(side);
      if (r) {
        zone.style.left   = r.x + 'px';
        zone.style.top    = r.y + 'px';
        zone.style.width  = r.w + 'px';
        zone.style.height = r.h + 'px';
      }
    });
  }

  let powerOut = false;
  let renderPaused = false;

  function draw() {
    if (!bg.complete || !bg.naturalWidth) return;

    const imgW = bg.naturalWidth;
    const imgH = bg.naturalHeight;
    const scale = H / imgH;
    const maxOffset = (imgW * scale) - W;
    const offsetX = scroll * maxOffset;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    const pof = window._powerOutEyeFrame;
    if (pof === 'black' || pof === 'jumpscare') return;

    const activeBg = getActiveBg();
    drawStripLayer(activeBg, imgW, imgH, scale, offsetX);

    if (!powerOut) {
      drawSprite(fanFrames[fanIndex], { x: fanAnimation.imgX, y: fanAnimation.imgY, scale: fanAnimation.scale }, scale, offsetX);
    }

    ['left', 'right'].forEach(side => {
      const anim   = doorAnim[side];
      const frames = doorFrames[side];
      const pos    = doorPos[side];
      drawSprite(frames[0], pos, scale, offsetX);
      if (anim.frameIndex > 0) {
        drawSprite(frames[anim.frameIndex], pos, scale, offsetX);
      }
    });

    if (!powerOut) {
      drawSprite(getBtnImg('left'),  btnPos.left,  scale, offsetX);
      drawSprite(getBtnImg('right'), btnPos.right, scale, offsetX);
      updateButtonZones();
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    if (renderPaused) return;
    if (!isDragging) {
      velocity *= 0.85;
      targetScroll += velocity;
    }
    targetScroll = clamp(targetScroll, 0, 1);
    scroll += (targetScroll - scroll) * 0.12;
    draw();
  }


  // ── Shared jumpscare player ───────────────────────────────────
  function playJumpscare(def, sfxSrc, onDone) {
    if (!def) { console.warn('playJumpscare: missing animation def'); return; }
    renderPaused = true;

    new Audio(sfxSrc).play().catch(() => {});

    const msPerFrame = 1000 / def.fps;
    let loaded = 0;

    const frames = def.frames.map(src => {
      const img = new Image();
      img.onload = img.onerror = () => { loaded++; if (loaded === frames.length) startPlaying(); };
      img.src = src;
      return img;
    });

    function startPlaying() {
      let frameIdx = 0;

      function nextFrame() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);

        const img = frames[frameIdx];
        if (img.naturalWidth) {
          const sc = Math.max(W / img.naturalWidth, H / img.naturalHeight);
          const dw = img.naturalWidth  * sc;
          const dh = img.naturalHeight * sc;
          ctx.drawImage(img, (W - dw) / 2, (H - dh) / 2, dw, dh);
        }

        frameIdx++;
        if (frameIdx < frames.length) {
          setTimeout(nextFrame, msPerFrame);
        } else {
          if (onDone) {
            onDone();
          } else {
            renderPaused = false;
          }
        }
      }

      nextFrame();
    }
  }

  // ── Individual jumpscare wrappers ─────────────────────────────
  const SCREAM  = '../Assets/FNaF 1 Audio/XSCREAM.wav';
  const SCREAM2 = '../Assets/FNaF 1 Audio/XSCREAM2.wav';
  const NOISE = '../Assets/FNaF 1 Audio/COMPUTER_DIGITAL_L2076505.wav';

  const GO_MENU = () => { ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); setTimeout(() => { window.location.href = 'menu.html'; }, 1500); };
  const GO_NOISE = () => { ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); setTimeout(() => { playJumpscare(noiseMenu, NOISE, GO_MENU); }, 500); };
  function playChicaJumpscare()       { playJumpscare(chicajumpscare,          SCREAM,  null); }
  function playFoxyJumpscare()        { playJumpscare(foxyJumpscare,           SCREAM,  null); }
  function playBonnieJumpscare()      { playJumpscare(bonnieJumpscare,         SCREAM,  null); }
  function playFreddyJumpscare()      { playJumpscare(freddyJumpscare,         SCREAM,  null); }
  function playGoldenFreddyJumpscare(){ playJumpscare(goldenFreddyJumpscare,   SCREAM2, null); }
  function playPowerOutJumpscare()    { playJumpscare(freddyJumpscarePowerOut, SCREAM,  GO_NOISE); }
  function playnoiseMenu()            { playJumpscare(noiseMenu,               NOISE,  GO_MENU); }

  // --- Debug ---
  let debugVisible = false;
  window.addEventListener('keydown', e => {
    if (e.key === 'd' || e.key === 'D') {
      debugVisible = !debugVisible;
      document.getElementById('debug').style.display = debugVisible ? 'block' : 'none';
    }
    if (e.key === 'j' || e.key === 'J') {
      const picks = [playChicaJumpscare, playBonnieJumpscare, playFoxyJumpscare, playFreddyJumpscare, playGoldenFreddyJumpscare, playnoiseMenu];
      picks[Math.floor(Math.random() * picks.length)]();
    }
  });

  function bindSlider(id, valId, side, prop, isFloat) {
    const el = document.getElementById(id);
    el.addEventListener('input', function() {
      btnPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindSlider('slx',  'vlx',  'left',  'x',     false);
  bindSlider('sly',  'vly',  'left',  'y',     false);
  bindSlider('slsc', 'vlsc', 'left',  'scale', true);
  bindSlider('srx',  'vrx',  'right', 'x',     false);
  bindSlider('sry',  'vry',  'right', 'y',     false);
  bindSlider('srsc', 'vrsc', 'right', 'scale', true);

  function bindDoorSlider(id, valId, side, prop, isFloat) {
    const el = document.getElementById(id);
    el.addEventListener('input', function() {
      doorPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindDoorSlider('sldx',  'vldx',  'left',  'x',     false);
  bindDoorSlider('sldy',  'vldy',  'left',  'y',     false);
  bindDoorSlider('sldsc', 'vldsc', 'left',  'scale', true);
  bindDoorSlider('srdx',  'vrdx',  'right', 'x',     false);
  bindDoorSlider('srdy',  'vrdy',  'right', 'y',     false);
  bindDoorSlider('srdsc', 'vrdsc', 'right', 'scale', true);

  document.getElementById('copy-btn').addEventListener('click', () => {
    const s = [
      `// Buttons`,
      `left:  { x: ${btnPos.left.x},  y: ${btnPos.left.y},  scale: ${btnPos.left.scale.toFixed(2)} },`,
      `right: { x: ${btnPos.right.x}, y: ${btnPos.right.y}, scale: ${btnPos.right.scale.toFixed(2)} }`,
      ``,
      `// Doors`,
      `left:  { imgX: ${doorPos.left.x},  imgY: ${doorPos.left.y},  scale: ${doorPos.left.scale.toFixed(2)} },`,
      `right: { imgX: ${doorPos.right.x}, imgY: ${doorPos.right.y}, scale: ${doorPos.right.scale.toFixed(2)} }`,
    ].join('\n');
    navigator.clipboard?.writeText(s);
    alert(s);
  });


  // --- Tablet ---
  const sfxCameraUp = new Audio('../Assets/FNaF 1 Audio/CAMERA_VIDEO_LOA_60105303.wav');
  const sfxCameraDown = new Audio('../Assets/FNaF 1 Audio/put down.wav')
  sfxCameraUp.volume = 0.5;
  sfxCameraDown.volume = 0.5;

  const tabletFrames = [];
  for (let i = 1; i <= tabletAnimation.frameCount; i++) {
    const img = new Image();
    img.src = `${tabletAnimation.basePath}${i}.png`;
    tabletFrames.push(img);
  }

  const tabletBar    = document.getElementById('tablet-bar');
  const tabletCanvas = document.getElementById('tablet-anim-canvas');
  const tabletCtx    = tabletCanvas.getContext('2d');
  const tabletCam    = document.getElementById('tablet-cam');

  let tabletState   = 'closed';
  let tabletFrame   = 0;
  let lastFrameTime = 0;

  function resizeTabletCanvas() {
    tabletCanvas.width  = window.innerWidth;
    tabletCanvas.height = window.innerHeight;
  }
  resizeTabletCanvas();
  window.addEventListener('resize', resizeTabletCanvas);

  function drawTabletFrame(idx) {
    const img = tabletFrames[idx];
    if (!img.complete || !img.naturalWidth) return;
    tabletCtx.clearRect(0, 0, tabletCanvas.width, tabletCanvas.height);
    const scale = Math.max(tabletCanvas.width / img.naturalWidth, tabletCanvas.height / img.naturalHeight);
    const dw = img.naturalWidth  * scale;
    const dh = img.naturalHeight * scale;
    const dx = (tabletCanvas.width  - dw) / 2;
    const dy = (tabletCanvas.height - dh) / 2;
    tabletCtx.drawImage(img, dx, dy, dw, dh);
  }

  function animateTablet(timestamp) {
    if (tabletState !== 'opening' && tabletState !== 'closing') return;

    if (timestamp - lastFrameTime > tabletAnimation.frameDelay) {
      lastFrameTime = timestamp;

      if (tabletState === 'opening') {
        drawTabletFrame(tabletFrame);
        tabletFrame++;
        if (tabletFrame >= tabletFrames.length) {
          tabletState = 'waiting';
          setTimeout(() => {
            tabletCanvas.style.display = 'none';
            tabletCam.style.display    = 'block';
            tabletBar.style.display    = 'none';
            tabletState = 'open';
          }, tabletAnimation.frameDelay);
          return;
        }
      } else if (tabletState === 'closing') {
        tabletFrame--;
        if (tabletFrame < 0) {
          tabletCanvas.style.display = 'none';
          tabletState = 'closed';
          canvas.style.display = 'block';
          tabletBar.style.display = 'flex';
          document.querySelectorAll('.btn-zone').forEach(z => z.style.display = 'block');
          return;
        }
        drawTabletFrame(tabletFrame);
      }
    }
    requestAnimationFrame(animateTablet);
  }

  function openTablet() {
    if (tabletState !== 'closed') return;
    if (GameState.rawPower <= 0) return;
    sfxCameraUp.currentTime = 0;
    sfxCameraUp.play().catch(() => {});
    tabletState  = 'opening';
    tabletFrame  = 0;
    tabletCanvas.style.display = 'block';
    tabletCanvas.width  = window.innerWidth;
    tabletCanvas.height = window.innerHeight;
    requestAnimationFrame(animateTablet);
  }

  function closeTablet() {
    if (tabletState !== 'open') return;
    sfxCameraDown.currentTime = 0;
    sfxCameraDown.play().catch(() => {});
    tabletState = 'closing';
    tabletFrame = tabletFrames.length - 1;
    tabletCam.style.display    = 'none';
    tabletCanvas.style.display = 'block';
    drawTabletFrame(tabletFrame);
    requestAnimationFrame(animateTablet);
  }

  tabletBar.addEventListener('click', openTablet);

  window.addEventListener('mousemove', e => {
    const fromBottom = window.innerHeight - e.clientY;
    if (fromBottom < 60 && tabletState === 'closed') openTablet();
    if (fromBottom < 60 && tabletState === 'open')   closeTablet();
  });

  // --- Mouse / touch pan controls ---
  canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    velocity = 0;
    document.body.classList.add('dragging');
    startAudio();
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    velocity = -(dx / maxOffset);
    targetScroll += velocity;
    lastX = e.clientX;
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
    document.body.classList.remove('dragging');
  });

  canvas.addEventListener('touchstart', e => {
    isDragging = true;
    lastX = e.touches[0].clientX;
    velocity = 0;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!isDragging) return;
    const dx = e.touches[0].clientX - lastX;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    velocity = -(dx / maxOffset);
    targetScroll += velocity;
    lastX = e.touches[0].clientX;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', () => { isDragging = false; });

  // Fade in on page load
  window.addEventListener('load', () => {
    const fadeEl = document.getElementById('page-fade');
    requestAnimationFrame(() => requestAnimationFrame(() => {
      fadeEl.style.opacity = '0';
    }));
  });

  // ── GameState ──────────────────────────────────────────────
  const HOURS        = ['12 AM','1 AM','2 AM','3 AM','4 AM','5 AM','6 AM'];
  const NIGHT_SECS   = 535;
  const SECS_PER_HOUR = NIGHT_SECS / 6;

  const PASSIVE_INTERVAL = { 1: 0, 2: 6, 3: 5, 4: 4, 5: 3, 6: 3, 7: 3 };

  const GameState = {
    night:        1,
    rawPower:     999,
    secondsElapsed: 0,
    passiveAccum:   0,

    getUsage() {
      let u = 1;
      if (state.left.door   === 'closed') u++;
      if (state.right.door  === 'closed') u++;
      if (state.left.light  === 'on')     u++;
      if (state.right.light === 'on')     u++;
      return Math.min(u, 5);
    },

    tick() {
      if (this.rawPower <= 0) {
        this.rawPower = 0;
        this.render();
        this.onPowerOut();
        return;
      }

      const usage = this.getUsage();
      this.rawPower -= usage;

      const interval = PASSIVE_INTERVAL[this.night] || 0;
      if (interval > 0) {
        this.passiveAccum++;
        if (this.passiveAccum >= interval) {
          this.passiveAccum = 0;
          this.rawPower -= 1;
        }
      }

      this.rawPower = Math.max(0, this.rawPower);

      this.secondsElapsed++;
      if (this.secondsElapsed >= NIGHT_SECS) {
        this.on6AM();
        return;
      }

      this.render();
    },

    getDisplayPercent() {
      return (Math.round(this.rawPower) / 10).toFixed(1);
    },

    getCurrentHour() {
      return Math.min(6, Math.floor(this.secondsElapsed / SECS_PER_HOUR));
    },

    render() {
      const usage   = this.getUsage();
      const pct     = this.getDisplayPercent();
      const fill    = document.getElementById('hud-power-bar-fill');
      const rawPct  = this.rawPower / 999 * 100;

      document.getElementById('hud-night').textContent     = `Night ${this.night}`;
      document.getElementById('hud-time').textContent      = HOURS[this.getCurrentHour()];
      document.getElementById('hud-power-val').textContent = `${pct}%`;
      document.getElementById('hud-usage-val').textContent =
              '█'.repeat(usage) + '░'.repeat(5 - usage);

      fill.style.width = `${rawPct}%`;
      fill.classList.remove('low', 'critical');
      if      (rawPct <= 15) fill.classList.add('critical');
      else if (rawPct <= 35) fill.classList.add('low');
    },

    onPowerOut() {
      if (this._powerOutTriggered) return;
      this._powerOutTriggered = true;

      powerOut = true;
      window._powerOutEyeFrame = '304';
      document.getElementById('hud').style.display        = 'none';
      document.getElementById('tablet-bar').style.display = 'none';
      document.querySelectorAll('.btn-zone').forEach(z => z.style.display = 'none');

      [sfxFan, sfxPhone, sfxLight].forEach(a => { a.pause(); a.currentTime = 0; });

      ['left', 'right'].forEach(side => {
        state[side].door  = 'open';
        state[side].light = 'off';
        startDoorAnim(side, -1);
      });

      const powerOutsfx = new Audio('../Assets/FNaF 1 Audio/powerdown.wav');
      powerOutsfx.play().catch(() => {});

      powerOutsfx.addEventListener('ended', () => {
        const steps1 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
        steps1.play().catch(() => {});

        steps1.addEventListener('ended', () => {
          const musicBox = new Audio('../Assets/FNaF 1 Audio/music box.wav');
          window._powerOutEyeFrame = '304';

          const schedule = [];

          const flickerPattern = [
            { img: '305', t: 0    },
            { img: '304', t: 120  },
            { img: '305', t: 280  },
            { img: '304', t: 420  },
            { img: '305', t: 620  },
            { img: '304', t: 800  },
            { img: '305', t: 1050 },
            { img: '304', t: 1300 },
            { img: '305', t: 1600 },
          ];
          flickerPattern.forEach(e => schedule.push(e));

          const blinkTimes = [
            4200, 8800, 13500, 17100, 21600, 25300,
            29800, 34200, 38700, 42100, 46500, 50900, 55300,
          ];
          blinkTimes.forEach(t => {
            if (t < 59000) {
              const dur = 250 + (t % 7) * 50;
              schedule.push({ img: '304', t });
              schedule.push({ img: '305', t: t + dur });
            }
          });

          schedule.sort((a, b) => a.t - b.t);
          schedule.forEach(({ img, t }) => {
            setTimeout(() => { window._powerOutEyeFrame = img; }, t);
          });

          musicBox.play().catch(() => {});

          musicBox.addEventListener('ended', () => {
            window._powerOutEyeFrame = 'black';

            setTimeout(() => {
              const steps2 = new Audio('../Assets/FNaF 1 Audio/deep steps.wav');
              steps2.play().catch(() => {});
              steps2.addEventListener('ended', () => {
                window._powerOutEyeFrame = 'jumpscare';
                playPowerOutJumpscare();
              });
            }, 500);
          });
        });
      });
    },

    on6AM() {
      console.log('6 AM — night complete');
    },
  };

  setInterval(() => GameState.tick(), 1000);
  GameState.render();

</script>
</body>
</html>