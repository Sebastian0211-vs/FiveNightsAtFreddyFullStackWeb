<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FNAF Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      cursor: grab;
      user-select: none;
    }
    body.dragging { cursor: grabbing; }
    canvas { display: block; position: absolute; top: 0; left: 0; }

    /* Invisible click zones for buttons — positioned by JS */
    .btn-zone {
      position: absolute;
      cursor: pointer;
      z-index: 10;
    }

    #debug {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.88);
      color: #0f0;
      font: 11px monospace;
      padding: 12px;
      border: 1px solid #0f0;
      z-index: 100;
      width: 240px;
    }
    #debug label { display: block; margin-top: 6px; }
    #debug input[type=range] { width: 100%; }
    #debug .val { color: #ff0; float: right; }
    #debug h3 { color: #0f0; margin-bottom: 2px; }
    #debug h4 { color: #aaffaa; margin-top: 8px; margin-bottom: 2px; }
    #debug .hint { color: #888; font-size: 10px; margin-top: 6px; }
    #copy-btn { margin-top: 8px; width: 100%; background: #0a0; color: #fff; border: none; padding: 4px; cursor: pointer; font: 11px monospace; }

    /* Tablet bar */
    #tablet-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40px;
      background: #1a1a1a;
      border-top: 2px solid #333;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    #tablet-bar img {
      height: 30px;
      opacity: 0.7;
    }
    #tablet-overlay {
      position: fixed;
      inset: 0;
      z-index: 40;
      display: none;
      background: #000;
    }
    #tablet-overlay canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: contain;
    }
    #tablet-cam {
      position: fixed;
      inset: 0;
      z-index: 41;
      display: none;
      background: #000;
    }
    #tablet-cam img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="debug">
  <h3>Debug [D to hide]</h3>
  <h4>Left Button</h4>
  <label>X: <span class="val" id="vlx">0</span>
    <input type="range" id="slx" min="0" max="3000" value="0">
  </label>
  <label>Y: <span class="val" id="vly">261</span>
    <input type="range" id="sly" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vlsc">1.00</span>
    <input type="range" id="slsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Button</h4>
  <label>X: <span class="val" id="vrx">1478</span>
    <input type="range" id="srx" min="0" max="3000" value="1478">
  </label>
  <label>Y: <span class="val" id="vry">261</span>
    <input type="range" id="sry" min="0" max="1500" value="261">
  </label>
  <label>Scale: <span class="val" id="vrsc">1.00</span>
    <input type="range" id="srsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Left Door</h4>
  <label>X: <span class="val" id="vldx">73</span>
    <input type="range" id="sldx" min="-500" max="3000" value="73">
  </label>
  <label>Y: <span class="val" id="vldy">41</span>
    <input type="range" id="sldy" min="-500" max="1500" value="41">
  </label>
  <label>Scale: <span class="val" id="vldsc">1.00</span>
    <input type="range" id="sldsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <h4>Right Door</h4>
  <label>X: <span class="val" id="vrdx">1263</span>
    <input type="range" id="srdx" min="-500" max="3000" value="1263">
  </label>
  <label>Y: <span class="val" id="vrdy">31</span>
    <input type="range" id="srdy" min="-500" max="1500" value="31">
  </label>
  <label>Scale: <span class="val" id="vrdsc">1.00</span>
    <input type="range" id="srdsc" min="0.1" max="3" step="0.01" value="1">
  </label>
  <div class="hint">Coords in source image pixels.</div>
  <button id="copy-btn">Copy values</button>
</div>

<div id="tablet-bar">
  <img src="../Assets/Tablette/open_tablette_icon.png" alt="tablet">
</div>
<canvas id="tablet-anim-canvas" style="display:none;position:fixed;inset:0;width:100%;height:100%;z-index:45;"></canvas>
<div id="tablet-cam" style="display:none;position:fixed;inset:0;z-index:44;background:#000;">
  <img src="../Assets/Cam_views/188.png" style="width:100%;height:100%;object-fit:contain;">
</div>

<!-- Animation data must load before the main script -->
<script src="animations.js"></script>
<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W, H;
  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // --- Audio ---
  const audioBase = '../Assets/FNaF 1 Audio/';
  const sfxFan = new Audio(audioBase + 'Buzz_Fan_Florescent2.wav');
  sfxFan.loop = true; sfxFan.volume = 0.5;
  const sfxPhone = new Audio(audioBase + 'voiceover1c.wav');
  const ambienceSrcs = [audioBase + 'ambience2.wav', audioBase + 'EerieAmbienceLargeSca_MV005.wav'];
  let audioStarted = false;

  function startAudio() {
    if (audioStarted) return;
    audioStarted = true;
    sfxFan.play().catch(() => {});
    sfxPhone.play().catch(() => {});
    function nextAmbience() {
      const a = new Audio(ambienceSrcs[Math.floor(Math.random() * ambienceSrcs.length)]);
      a.volume = 0.4;
      a.play().catch(() => {});
      a.addEventListener('ended', nextAmbience);
    }
    nextAmbience();
  }
  window.addEventListener('click', startAudio, { once: true });
  window.addEventListener('keydown', startAudio, { once: true });

  // --- Background images ---
  const bg = new Image();
  bg.src = '../assets/Main Room/519.png';

  const bgLit = {
    left:  new Image(),
    right: new Image(),
  };
  bgLit.left.src  = '../Assets/Main Room/main_room_left_open_lit.png';
  bgLit.right.src = '../Assets/Main Room/main_room_right_open_lit.png';

  function getActiveBg() {
    const leftLit  = state.left.light  === 'on';
    const rightLit = state.right.light === 'on';
    if (leftLit  && !rightLit) return bgLit.left.complete  && bgLit.left.naturalWidth  ? bgLit.left  : bg;
    if (rightLit && !leftLit)  return bgLit.right.complete && bgLit.right.naturalWidth ? bgLit.right : bg;
    return bg;
  }

  // --- Fan (loaded from fanAnimation defined in animations.js) ---
  const fanFrames = fanAnimation.frames.map(src => {
    const img = new Image();
    img.src = src;
    return img;
  });
  let fanIndex  = 0;
  let fanLoaded = 0;
  fanFrames.forEach(f => {
    f.onload  = () => { fanLoaded++; if (fanLoaded === fanFrames.length) setInterval(() => { fanIndex = (fanIndex + 1) % fanFrames.length; }, 1000 / fanAnimation.fps); };
    f.onerror = () => { fanLoaded++; };
  });

  // --- Doors (loaded from mainRoomDoorLeft/Right defined in animations.js) ---
  const sfxDoor = new Audio('../Assets/FNaF 1 Audio/SFXBible_12478.wav');
  sfxDoor.volume = 0.8;

  function loadDoorFrames(animDef) {
    return animDef.frames.map(src => {
      const img = new Image();
      img.src = src;
      img.onerror = () => console.warn('Missing door frame:', src);
      return img;
    });
  }

  const doorFrames = {
    left:  loadDoorFrames(mainRoomDoorLeft),
    right: loadDoorFrames(mainRoomDoorRight),
  };

  // Per-door animation state
  // frameIndex: 0 = door frame only (open), last = fully closed
  // direction:  0 = idle, 1 = closing, -1 = opening
  const doorAnim = {
    left:  { frameIndex: 0, direction: 0, timer: null },
    right: { frameIndex: 0, direction: 0, timer: null },
  };

  function stepDoor(side) {
    const anim   = doorAnim[side];
    const frames = doorFrames[side];
    anim.frameIndex += anim.direction;

    if (anim.frameIndex >= frames.length) {
      anim.frameIndex = frames.length - 1;
      anim.direction  = 0;
      clearInterval(anim.timer); anim.timer = null;
      state[side].door = 'closed';
    } else if (anim.frameIndex <= 0) {
      anim.frameIndex = 0;
      anim.direction  = 0;
      clearInterval(anim.timer); anim.timer = null;
      state[side].door = 'open';
    }
  }

  function startDoorAnim(side, direction) {
    const anim = doorAnim[side];
    const def  = side === 'left' ? mainRoomDoorLeft : mainRoomDoorRight;
    if (anim.direction === direction) return;
    anim.direction = direction;
    if (anim.timer) { clearInterval(anim.timer); anim.timer = null; }
    anim.timer = setInterval(() => stepDoor(side), 1000 / def.fps);
  }

  function toggleDoor(side) {
    const anim = doorAnim[side];
    sfxDoor.currentTime = 0;
    sfxDoor.play().catch(() => {});
    if (anim.direction === 1 || (anim.direction === 0 && anim.frameIndex === doorFrames[side].length - 1)) {
      startDoorAnim(side, -1); // open
    } else {
      startDoorAnim(side, 1);  // close
    }
  }

  // --- Button images ---
  const btnBase = '../Assets/Door_Buttons/';
  function loadBtn(side, light, door) {
    const img = new Image();
    img.src = `${btnBase}Button_${side}_light_${light}_${door}.png`;
    return img;
  }

  const btnImgs = {
    left: {
      off_closed: loadBtn('left',  'off', 'closed'),
      off_open:   loadBtn('left',  'off', 'open'),
      on_closed:  loadBtn('left',  'on',  'closed'),
      on_open:    loadBtn('left',  'on',  'open'),
    },
    right: {
      off_closed: loadBtn('right', 'off', 'closed'),
      off_open:   loadBtn('right', 'off', 'open'),
      on_closed:  loadBtn('right', 'on',  'closed'),
      on_open:    loadBtn('right', 'on',  'open'),
    }
  };

  // Button states
  const state = {
    left:  { door: 'closed', light: 'off' },
    right: { door: 'closed', light: 'off' },
  };

  function getBtnImg(side) {
    const s = state[side];
    return btnImgs[side][`${s.light}_${s.door}`];
  }

  // Button images — onerror so missing files don't break anything
  [...Object.values(btnImgs.left), ...Object.values(btnImgs.right)].forEach(img => {
    img.onerror = () => { console.warn('Missing:', img.src); };
  });

  // Start render loop as soon as bg loads
  bg.onload = () => requestAnimationFrame(animate);

  // --- Pan ---
  let scroll = 0.5;
  let targetScroll = 0.5;
  let isDragging = false;
  let lastX = 0;
  let velocity = 0;

  // Button positions (image-space)
  let btnPos = {
    left:  { x: 0,    y: 261, scale: 1.0 },
    right: { x: 1478, y: 261, scale: 1.0 },
  };

  // Door positions (image-space) — tune with debug sliders
  let doorPos = {
    left:  { x: mainRoomDoorLeft.imgX,  y: mainRoomDoorLeft.imgY,  scale: mainRoomDoorLeft.scale  },
    right: { x: mainRoomDoorRight.imgX, y: mainRoomDoorRight.imgY, scale: mainRoomDoorRight.scale },
  };

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  const FOV_FACTOR = 0.35;

  function drawStripLayer(img, imgW, imgH, scale, offsetX) {
    for (let sx = 0; sx < W; sx++) {
      const imgX = (offsetX + sx) / scale;
      if (imgX < 0 || imgX >= imgW) continue;
      const screenNorm = (sx / W - 0.5) * 2;
      const dist = Math.sqrt(1 + (screenNorm * FOV_FACTOR) ** 2);
      const stripH = H / dist;
      const yOff = (H - stripH) / 2;
      ctx.drawImage(img, imgX, 0, 1, imgH, sx, yOff, 1, stripH);
    }
  }

  function drawSprite(img, imgSpace, scale, offsetX) {
    if (!img.complete || !img.naturalWidth) return;
    const sx = imgSpace.x * scale - offsetX;
    const sy = imgSpace.y * scale;
    const dw = img.naturalWidth  * scale * imgSpace.scale;
    const dh = img.naturalHeight * scale * imgSpace.scale;
    ctx.drawImage(img, sx, sy, dw, dh);
  }

  // Screen rect of a button (for click detection)
  function getBtnScreenRect(side) {
    if (!bg || !bg.complete || !bg.naturalWidth) return null;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    const offsetX = scroll * maxOffset;
    const pos = btnPos[side];
    const img = getBtnImg(side);
    if (!img.complete || !img.naturalWidth) return null;
    return {
      x: pos.x * scale - offsetX,
      y: pos.y * scale,
      w: img.naturalWidth  * scale * pos.scale,
      h: img.naturalHeight * scale * pos.scale,
    };
  }

  // Invisible HTML zones for button clicks (updated each frame)
  function updateButtonZones() {
    if (!bg || !bg.naturalWidth) return;
    ['left', 'right'].forEach(side => {
      let zone = document.getElementById('zone-' + side);
      if (!zone) {
        zone = document.createElement('div');
        zone.id = 'zone-' + side;
        zone.className = 'btn-zone';
        document.body.appendChild(zone);

        zone.addEventListener('click', e => {
          startAudio();
          const rect = zone.getBoundingClientRect();
          const relY = e.clientY - rect.top;
          // Top half = door toggle, bottom half = light toggle
          if (relY < rect.height / 2) {
            toggleDoor(side);
          } else {
            state[side].light = state[side].light === 'off' ? 'on' : 'off';
          }
        });
      }

      const r = getBtnScreenRect(side);
      if (r) {
        zone.style.left   = r.x + 'px';
        zone.style.top    = r.y + 'px';
        zone.style.width  = r.w + 'px';
        zone.style.height = r.h + 'px';
      }
    });
  }

  function draw() {
    if (!bg.complete || !bg.naturalWidth) return;

    const imgW = bg.naturalWidth;
    const imgH = bg.naturalHeight;
    const scale = H / imgH;
    const maxOffset = (imgW * scale) - W;
    const offsetX = scroll * maxOffset;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, W, H);

    const activeBg = getActiveBg();
    drawStripLayer(activeBg, imgW, imgH, scale, offsetX);
    drawSprite(fanFrames[fanIndex], { x: fanAnimation.imgX, y: fanAnimation.imgY, scale: fanAnimation.scale }, scale, offsetX);

    // Draw doors — frame 0 is always visible (door frame/surround).
    // Frames 1+ are the closing panels that animate on top.
    ['left', 'right'].forEach(side => {
      const anim   = doorAnim[side];
      const frames = doorFrames[side];
      const pos    = doorPos[side];
      drawSprite(frames[0], pos, scale, offsetX);
      if (anim.frameIndex > 0) {
        drawSprite(frames[anim.frameIndex], pos, scale, offsetX);
      }
    });

    drawSprite(getBtnImg('left'),  btnPos.left,  scale, offsetX);
    drawSprite(getBtnImg('right'), btnPos.right, scale, offsetX);

    updateButtonZones();
  }

  function animate() {
    requestAnimationFrame(animate);
    if (!isDragging) {
      velocity *= 0.85;
      targetScroll += velocity;
    }
    targetScroll = clamp(targetScroll, 0, 1);
    scroll += (targetScroll - scroll) * 0.12;
    draw();
  }


  // --- Debug ---
  let debugVisible = false;
  window.addEventListener('keydown', e => {
    if (e.key === 'd' || e.key === 'D') {
      debugVisible = !debugVisible;
      document.getElementById('debug').style.display = debugVisible ? 'block' : 'none';
    }
  });

  function bindSlider(id, valId, side, prop, isFloat) {
    const el = document.getElementById(id);
    el.addEventListener('input', function() {
      btnPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindSlider('slx',  'vlx',  'left',  'x',     false);
  bindSlider('sly',  'vly',  'left',  'y',     false);
  bindSlider('slsc', 'vlsc', 'left',  'scale', true);
  bindSlider('srx',  'vrx',  'right', 'x',     false);
  bindSlider('sry',  'vry',  'right', 'y',     false);
  bindSlider('srsc', 'vrsc', 'right', 'scale', true);

  // Door sliders — write into doorPos instead of btnPos
  function bindDoorSlider(id, valId, side, prop, isFloat) {
    const el = document.getElementById(id);
    el.addEventListener('input', function() {
      doorPos[side][prop] = isFloat ? parseFloat(this.value) : +this.value;
      document.getElementById(valId).textContent = isFloat ? parseFloat(this.value).toFixed(2) : this.value;
    });
  }
  bindDoorSlider('sldx',  'vldx',  'left',  'x',     false);
  bindDoorSlider('sldy',  'vldy',  'left',  'y',     false);
  bindDoorSlider('sldsc', 'vldsc', 'left',  'scale', true);
  bindDoorSlider('srdx',  'vrdx',  'right', 'x',     false);
  bindDoorSlider('srdy',  'vrdy',  'right', 'y',     false);
  bindDoorSlider('srdsc', 'vrdsc', 'right', 'scale', true);

  document.getElementById('copy-btn').addEventListener('click', () => {
    const s = [
      `// Buttons`,
      `left:  { x: ${btnPos.left.x},  y: ${btnPos.left.y},  scale: ${btnPos.left.scale.toFixed(2)} },`,
      `right: { x: ${btnPos.right.x}, y: ${btnPos.right.y}, scale: ${btnPos.right.scale.toFixed(2)} }`,
      ``,
      `// Doors`,
      `left:  { imgX: ${doorPos.left.x},  imgY: ${doorPos.left.y},  scale: ${doorPos.left.scale.toFixed(2)} },`,
      `right: { imgX: ${doorPos.right.x}, imgY: ${doorPos.right.y}, scale: ${doorPos.right.scale.toFixed(2)} }`,
    ].join('\n');
    navigator.clipboard?.writeText(s);
    alert(s);
  });


  // --- Tablet (frame list built from tabletAnimation defined in animations.js) ---
  const sfxCamera = new Audio('../Assets/FNaF 1 Audio/CAMERA_VIDEO_LOA_60105303.wav');
  const sfxCameraDown = new Audio('../Assets/FNaF 1 Audio/put down.wav')
  sfxCamera.volume = 0.8;

  const tabletFrames = [];
  for (let i = 1; i <= tabletAnimation.frameCount; i++) {
    const img = new Image();
    img.src = `${tabletAnimation.basePath}${i}.png`;
    tabletFrames.push(img);
  }

  const tabletBar    = document.getElementById('tablet-bar');
  const tabletCanvas = document.getElementById('tablet-anim-canvas');
  const tabletCtx    = tabletCanvas.getContext('2d');
  const tabletCam    = document.getElementById('tablet-cam');

  let tabletState   = 'closed'; // closed | opening | waiting | open | closing
  let tabletFrame   = 0;
  let lastFrameTime = 0;

  function resizeTabletCanvas() {
    tabletCanvas.width  = window.innerWidth;
    tabletCanvas.height = window.innerHeight;
  }
  resizeTabletCanvas();
  window.addEventListener('resize', resizeTabletCanvas);

  function drawTabletFrame(idx) {
    const img = tabletFrames[idx];
    if (!img.complete || !img.naturalWidth) return;
    tabletCtx.clearRect(0, 0, tabletCanvas.width, tabletCanvas.height);
    const scale = Math.max(tabletCanvas.width / img.naturalWidth, tabletCanvas.height / img.naturalHeight);
    const dw = img.naturalWidth  * scale;
    const dh = img.naturalHeight * scale;
    const dx = (tabletCanvas.width  - dw) / 2;
    const dy = (tabletCanvas.height - dh) / 2;
    tabletCtx.drawImage(img, dx, dy, dw, dh);
  }

  function animateTablet(timestamp) {
    if (tabletState !== 'opening' && tabletState !== 'closing') return;

    if (timestamp - lastFrameTime > tabletAnimation.frameDelay) {
      lastFrameTime = timestamp;

      if (tabletState === 'opening') {
        drawTabletFrame(tabletFrame);
        tabletFrame++;
        if (tabletFrame >= tabletFrames.length) {
          tabletState = 'waiting';
          setTimeout(() => {
            tabletCanvas.style.display = 'none';
            tabletCam.style.display    = 'block';
            tabletBar.style.display    = 'none';
            tabletState = 'open';
          }, tabletAnimation.frameDelay);
          return;
        }
      } else if (tabletState === 'closing') {
        tabletFrame--;
        if (tabletFrame < 0) {
          tabletCanvas.style.display = 'none';
          tabletState = 'closed';
          canvas.style.display = 'block';
          tabletBar.style.display = 'flex';
          document.querySelectorAll('.btn-zone').forEach(z => z.style.display = 'block');
          return;
        }
        drawTabletFrame(tabletFrame);
      }
    }
    requestAnimationFrame(animateTablet);
  }

  function openTablet() {
    if (tabletState !== 'closed') return;
    sfxCamera.currentTime = 0;
    sfxCamera.play().catch(() => {});
    tabletState  = 'opening';
    tabletFrame  = 0;
    tabletCanvas.style.display = 'block';
    tabletCanvas.width  = window.innerWidth;
    tabletCanvas.height = window.innerHeight;
    requestAnimationFrame(animateTablet);
  }

  function closeTablet() {
    if (tabletState !== 'open') return;
    sfxCameraDown.currentTime = 0;
    sfxCameraDown.play().catch(() => {});
    tabletState = 'closing';
    tabletFrame = tabletFrames.length - 1;
    tabletCam.style.display    = 'none';
    tabletCanvas.style.display = 'block';
    drawTabletFrame(tabletFrame);
    requestAnimationFrame(animateTablet);
  }

  tabletBar.addEventListener('click', openTablet);

  window.addEventListener('mousemove', e => {
    const fromBottom = window.innerHeight - e.clientY;
    if (fromBottom < 60 && tabletState === 'closed') openTablet();
    if (fromBottom < 60 && tabletState === 'open')   closeTablet();
  });

  // --- Mouse / touch pan controls ---
  canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    velocity = 0;
    document.body.classList.add('dragging');
    startAudio();
  });
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    velocity = -(dx / maxOffset);
    targetScroll += velocity;
    lastX = e.clientX;
  });
  window.addEventListener('mouseup', () => {
    isDragging = false;
    document.body.classList.remove('dragging');
  });

  canvas.addEventListener('touchstart', e => {
    isDragging = true;
    lastX = e.touches[0].clientX;
    velocity = 0;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!isDragging) return;
    const dx = e.touches[0].clientX - lastX;
    const scale = H / bg.naturalHeight;
    const maxOffset = (bg.naturalWidth * scale) - W;
    velocity = -(dx / maxOffset);
    targetScroll += velocity;
    lastX = e.touches[0].clientX;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', () => { isDragging = false; });
</script>
</body>
</html>